{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#scara-ros2-ethercat-workshop","title":"SCARA ROS2 EtherCAT Workshop","text":"<p>Welcome to the SCARA ROS2 EtherCAT Workshop! This comprehensive tutorial will guide you through the fundamentals of controlling robotic systems using the ros2_control framework and EtherCAT communication.</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>The ros2_control framework is a real-time control framework designed for general robotics applications that is gaining increasing attention in both research and industrial contexts. This tutorial is designed to help you understand the basic concepts of controlling a robot using ros2_control and EtherCAT.</p>"},{"location":"#what-youll-learn","title":"What You'll Learn","text":"<p>This workshop covers the following topics:</p> <ul> <li> <p> URDF Description</p> <p>Learn how to write a complete URDF description for a simple SCARA manipulator, including geometry, dynamics, and ros2_control interfaces.</p> <p> URDF Tutorial</p> </li> <li> <p> Launch &amp; Interact</p> <p>Discover how to launch your robot system and interact with controllers through the Controller Manager.</p> <p> Launch Tutorial</p> </li> <li> <p> Hardware Interface</p> <p>Develop custom hardware interfaces to communicate with your robot's physical hardware or simulation.</p> <p> Hardware Tutorial</p> </li> <li> <p> Controller Development</p> <p>Write custom controllers tailored to your specific application requirements.</p> <p> Controller Tutorial</p> </li> <li> <p> Gazebo Simulation</p> <p>Set up your SCARA manipulator to run with ros2_control and Gazebo for realistic physics simulation.</p> <p> Gazebo Tutorial</p> </li> <li> <p> EtherCAT Integration</p> <p>Configure and control CIA 402 compliant EtherCAT motor drives using the ethercat_driver_ros2 stack.</p> <p> EtherCAT Tutorial</p> </li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>System Requirements</p> <ul> <li>Operating System: Ubuntu 24.04 LTS</li> <li>ROS Distribution: ROS2 Jazzy</li> <li>Basic Knowledge: Familiarity with ROS2, C++, and Python</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Ready to get started? Follow our installation guide:</p> <p>Get Started </p>"},{"location":"#the-scara-robot","title":"The SCARA Robot","text":"<p>Throughout this tutorial, we'll work with a SCARA (Selective Compliance Assembly Robot Arm) manipulator. This robot type is commonly used in industrial applications for pick-and-place operations, assembly tasks, and more.</p>"},{"location":"#robot-structure","title":"Robot Structure","text":"<p>The SCARA robot consists of:</p> <ul> <li>3 Degrees of Freedom: Two revolute joints for horizontal movement and one prismatic joint for vertical movement</li> <li>Joint 1 &amp; 2: Revolute joints controlling the arm position in the XY plane</li> <li>Joint 3: Prismatic joint controlling the vertical (Z-axis) position</li> </ul>"},{"location":"#ros2_control-framework","title":"ros2_control Framework","text":"<p>Before diving into the tutorials, it's helpful to understand the ros2_control framework architecture:</p> <ul> <li>Controller Manager: Orchestrates the control loop and manages controller lifecycle</li> <li>Hardware Interface: Abstracts physical hardware or simulation</li> <li>Controllers: Implement control algorithms for your robot</li> <li>Resource Manager: Manages hardware resources and interfaces</li> </ul> <p>For a detailed overview, see the ros2_control Overview.</p>"},{"location":"#support-contribution","title":"Support &amp; Contribution","text":"<p>Need Help?</p> <p>If you encounter any issues or have questions:</p> <ul> <li>Check the tutorial documentation</li> <li>Open an issue on GitHub</li> <li>Contact the maintainers (see Contacts)</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is open source. Check the repository for license information.</p>"},{"location":"#icube-laboratory","title":"ICube Laboratory","text":"<p>University of Strasbourg, France</p>"},{"location":"#asterion-robotics","title":"Asterion Robotics","text":""},{"location":"about/contacts/","title":"Contacts","text":""},{"location":"about/contacts/#contacts","title":"Contacts","text":""},{"location":"about/contacts/#maintainers","title":"Maintainers","text":"<p>This project is maintained by the ICube Laboratory at the University of Strasbourg and Asterion Robotics.</p>"},{"location":"about/contacts/#icube-laboratory","title":"ICube Laboratory","text":"<p>ICube Laboratory University of Strasbourg, France</p>"},{"location":"about/contacts/#team-member","title":"Team Member","text":"<p>Manuel Yguel</p> <ul> <li>Email: yguel@unistra.fr</li> <li>GitHub: @yguel</li> </ul>"},{"location":"about/contacts/#asterion-robotics","title":"Asterion Robotics","text":"<p>Asterion Robotics </p>"},{"location":"about/contacts/#team-member_1","title":"Team Member","text":"<p>Maciej Bednarczyk</p> <ul> <li>Email: m.bednarczyk@asterion-robotics.com</li> <li>GitHub: @mcbed</li> </ul>"},{"location":"about/contacts/#license","title":"License","text":"<p>This project is open source. Check the LICENSE file in the repository for details.</p>"},{"location":"about/contacts/#questions","title":"Questions?","text":"<p>Feel free to reach out to any of the maintainers above!</p>"},{"location":"getting-started/docker/","title":"Docker Setup","text":""},{"location":"getting-started/docker/#docker-setup","title":"Docker Setup","text":"<p>Docker provides an isolated, pre-configured environment for running the SCARA ROS2 EtherCAT Workshop without modifying your host system.</p>"},{"location":"getting-started/docker/#prerequisites","title":"Prerequisites","text":"<p>Requirements</p> <ul> <li>Docker installed on your system</li> <li>At least 8 GB of disk space</li> <li>(Optional) rocker for GUI support</li> </ul>"},{"location":"getting-started/docker/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/docker/#basic-docker-setup","title":"Basic Docker Setup","text":"<ol> <li>Clone the repository (if you haven't already):</li> </ol> <pre><code>git clone https://github.com/ICube-Robotics/ecat_ros2_workshop.git\ncd ecat_ros2_workshop\n</code></pre> <ol> <li>Build the Docker image:</li> </ol> <pre><code>docker build --tag ecat_ros2_workshop:jazzy --file .docker/Dockerfile .\n</code></pre> <p>Build Time</p> <p>The first build may take 10-20 minutes depending on your internet connection and system performance.</p> <ol> <li>Run the container:</li> </ol> <pre><code>docker run ecat_ros2_workshop:jazzy ros2 launch scara_bringup scara.launch.py\n</code></pre>"},{"location":"getting-started/docker/#running-with-gui","title":"Running with GUI","text":""},{"location":"getting-started/docker/#option-1-using-rocker-recommended","title":"Option 1: Using Rocker (Recommended)","text":"<p>Rocker provides seamless X11 forwarding and device access.</p> <ol> <li>Install rocker:</li> </ol> <pre><code>sudo apt update\nsudo apt install python3-rocker\n</code></pre> <ol> <li>Run with GUI support:</li> </ol> <pre><code>rocker --net=host --x11 --devices /dev/dri --user ecat_ros2_workshop:jazzy ros2 launch scara_bringup scara.launch.py\n</code></pre> <p>Rocker Options</p> <ul> <li><code>--net=host</code>: Uses host networking for ROS2 communication</li> <li><code>--x11</code>: Enables X11 forwarding for GUI applications</li> <li><code>--devices /dev/dri</code>: Mounts Direct Rendering Infrastructure for hardware-accelerated graphics (Intel GPUs)</li> <li><code>--user</code>: Runs as non-root user for better security</li> </ul>"},{"location":"getting-started/docker/#option-2-using-novnc-web-based","title":"Option 2: Using noVNC (Web-Based)","text":"<p>noVNC provides a web-based VNC client accessible through your browser - no X11 configuration needed!</p> <ol> <li>Build the noVNC image:</li> </ol> <pre><code># First ensure the base image is built\ndocker build --tag ecat_ros2_workshop:jazzy --file .docker/Dockerfile .\n\n# Build the noVNC image\ndocker build --tag ecat_ros2_workshop:jazzy_novnc --file .docker/Dockerfile_novnc .\n</code></pre> <ol> <li>Run the noVNC container:</li> </ol> <pre><code>docker run --rm -p 6080:6080 -it ecat_ros2_workshop:jazzy_novnc\n</code></pre> <ol> <li>Access the desktop:</li> </ol> <p>Open your web browser and navigate to: </p><pre><code>http://localhost:6080/vnc.html\n</code></pre><p></p> <ol> <li>Inside the noVNC session, open a terminal and run:</li> </ol> <pre><code>cd ros2_dev/ecat_ros2_workshop/\nsource install/setup.bash\nros2 launch scara_bringup scara.launch.py\n</code></pre> <p>Browser Compatibility</p> <p>noVNC works best with modern browsers (Chrome, Firefox, Edge). For optimal performance, use a desktop browser rather than mobile.</p>"},{"location":"getting-started/docker/#interactive-shell","title":"Interactive Shell","text":"<p>To explore and interact with the environment:</p> <pre><code>docker run -it ecat_ros2_workshop:jazzy\n</code></pre> <p>Inside the container:</p> <pre><code>cd ros2_dev/ecat_ros2_workshop/\nsource install/setup.bash\n\n# Now you can run any ROS2 commands\nros2 launch scara_bringup scara.launch.py\nros2 topic list\nros2 control list_controllers\n</code></pre>"},{"location":"getting-started/docker/#development-workflow","title":"Development Workflow","text":""},{"location":"getting-started/docker/#mounting-local-code","title":"Mounting Local Code","text":"<p>To develop code on your host and run it in the container:</p> <pre><code>docker run -it \\\n  -v $(pwd):/workspace \\\n  -w /workspace \\\n  ecat_ros2_workshop:jazzy \\\n  bash\n</code></pre> <p>Inside the container:</p> <pre><code># Rebuild after changes\ncolcon build\nsource install/setup.bash\nros2 launch scara_bringup scara.launch.py\n</code></pre>"},{"location":"getting-started/docker/#persistent-container","title":"Persistent Container","text":"<p>Create a named container to preserve your changes:</p> <pre><code># Create and start the container\ndocker run -it --name scara_dev ecat_ros2_workshop:jazzy bash\n\n# Later, restart and attach to the same container\ndocker start scara_dev\ndocker attach scara_dev\n</code></pre>"},{"location":"getting-started/docker/#hardware-acceleration","title":"Hardware Acceleration","text":""},{"location":"getting-started/docker/#nvidia-gpu-support","title":"NVIDIA GPU Support","text":"<p>For NVIDIA GPU support, use the NVIDIA Container Toolkit:</p> <pre><code># Install NVIDIA Container Toolkit\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\ncurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\\n  sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n\nsudo apt update\nsudo apt install -y nvidia-container-toolkit\nsudo systemctl restart docker\n\n# Run with GPU support\ndocker run --gpus all -it ecat_ros2_workshop:jazzy\n</code></pre>"},{"location":"getting-started/docker/#intel-integrated-graphics","title":"Intel Integrated Graphics","text":"<p>For Intel integrated graphics (already included in rocker command):</p> <pre><code>rocker --devices /dev/dri ecat_ros2_workshop:jazzy\n</code></pre>"},{"location":"getting-started/docker/#docker-compose-advanced","title":"Docker Compose (Advanced)","text":"<p>For more complex setups, create a <code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  scara_workshop:\n    image: ecat_ros2_workshop:jazzy\n    container_name: scara_workshop\n    stdin_open: true\n    tty: true\n    network_mode: host\n    environment:\n      - DISPLAY=${DISPLAY}\n      - QT_X11_NO_MITSHM=1\n    volumes:\n      - /tmp/.X11-unix:/tmp/.X11-unix:rw\n      - ./:/workspace\n    devices:\n      - /dev/dri:/dev/dri\n    command: bash\n</code></pre> <p>Run with:</p> <pre><code>xhost +local:docker\ndocker-compose up\n</code></pre>"},{"location":"getting-started/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/docker/#display-issues","title":"Display Issues","text":"<p>If you encounter display errors with rocker:</p> <pre><code># Allow Docker to connect to X server\nxhost +local:docker\n\n# Run rocker again\nrocker --x11 ecat_ros2_workshop:jazzy\n</code></pre>"},{"location":"getting-started/docker/#network-issues","title":"Network Issues","text":"<p>If ROS2 nodes can't communicate:</p> <pre><code># Use host networking\ndocker run --net=host -it ecat_ros2_workshop:jazzy\n</code></pre>"},{"location":"getting-started/docker/#permission-denied","title":"Permission Denied","text":"<p>If you get permission errors:</p> <pre><code># Add your user to docker group\nsudo usermod -aG docker $USER\n\n# Log out and back in for changes to take effect\n</code></pre>"},{"location":"getting-started/docker/#container-size","title":"Container Size","text":"<p>To check Docker disk usage:</p> <pre><code>docker system df\n\n# Clean up unused containers and images\ndocker system prune -a\n</code></pre>"},{"location":"getting-started/docker/#comparison-docker-methods","title":"Comparison: Docker Methods","text":"Method Pros Cons Best For Basic Simple, fast No GUI Headless testing Rocker Native performance, hardware acceleration Requires X11 setup Local development noVNC Works anywhere, no X11 needed Slight latency Remote access, web-based"},{"location":"getting-started/docker/#next-steps","title":"Next Steps","text":"<p>Now that you have Docker set up:</p> <ul> <li>Continue with the ros2_control Overview</li> <li>Try running the tutorials inside Docker</li> <li>Explore the URDF Tutorial</li> </ul> <p>Tip: Docker is great for trying things out, but for serious development, consider a native installation for better performance.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#installation-guide","title":"Installation Guide","text":"<p>This guide will walk you through setting up the SCARA ROS2 EtherCAT Workshop on your system.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>Required Setup</p> <ul> <li>Operating System: Ubuntu 24.04 LTS</li> <li>ROS Distribution: ROS2 Jazzy</li> <li>Disk Space: ~5 GB free space</li> <li>Memory: 4 GB RAM minimum (8 GB recommended)</li> </ul>"},{"location":"getting-started/installation/#step-by-step-installation","title":"Step-by-Step Installation","text":""},{"location":"getting-started/installation/#1-install-ros2-jazzy","title":"1. Install ROS2 Jazzy","text":"<p>Follow the official ROS2 installation instructions for Ubuntu 24.04:</p> <pre><code># Add ROS2 apt repository\nsudo apt install software-properties-common\nsudo add-apt-repository universe\nsudo apt update &amp;&amp; sudo apt install curl -y\n\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\n\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n\n# Install ROS2 Jazzy Desktop\nsudo apt update\nsudo apt install ros-jazzy-desktop -y\n</code></pre> <p>For detailed instructions, visit the official ROS2 documentation.</p>"},{"location":"getting-started/installation/#2-source-ros2-environment","title":"2. Source ROS2 Environment","text":"<p>After installation, source your ROS2 environment:</p> <pre><code>source /opt/ros/jazzy/setup.bash\n</code></pre> <p>Auto-sourcing</p> <p>If you're only using ROS2 Jazzy, add the source command to your <code>~/.bashrc</code> file: </p><pre><code>echo \"source /opt/ros/jazzy/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre><p></p>"},{"location":"getting-started/installation/#3-install-colcon","title":"3. Install Colcon","text":"<p>Colcon is the build tool for ROS2 workspaces:</p> <pre><code>sudo apt install python3-colcon-common-extensions\n</code></pre>"},{"location":"getting-started/installation/#4-create-a-ros2-workspace","title":"4. Create a ROS2 Workspace","text":"<p>Create a workspace directory for the tutorial:</p> <pre><code>mkdir -p ~/ros2_ws/src\ncd ~/ros2_ws\n</code></pre>"},{"location":"getting-started/installation/#5-clone-the-repository","title":"5. Clone the Repository","text":"<p>Clone the workshop repository into your workspace:</p> <pre><code>cd ~/ros2_ws/src\ngit clone https://github.com/ICube-Robotics/ecat_ros2_workshop.git\n</code></pre>"},{"location":"getting-started/installation/#6-install-dependencies","title":"6. Install Dependencies","text":"<p>Use <code>rosdep</code> to install all required dependencies:</p> <pre><code>cd ~/ros2_ws\nsudo apt update\nrosdep update\nrosdep install --from-paths src --ignore-src -y -r\n</code></pre> <p>Note</p> <p>If this is your first time using <code>rosdep</code>, you may need to initialize it: </p><pre><code>sudo rosdep init\nrosdep update\n</code></pre><p></p>"},{"location":"getting-started/installation/#7-build-the-workspace","title":"7. Build the Workspace","text":"<p>Build the workspace using colcon:</p> <pre><code>cd ~/ros2_ws\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Release --symlink-install\n</code></pre> <p>Build Options</p> <ul> <li><code>--cmake-args -DCMAKE_BUILD_TYPE=Release</code>: Optimizes the build for performance</li> <li><code>--symlink-install</code>: Creates symbolic links instead of copying files (useful during development)</li> </ul>"},{"location":"getting-started/installation/#8-source-the-workspace","title":"8. Source the Workspace","text":"<p>After building, source the workspace:</p> <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre> <p>Auto-sourcing Workspace</p> <p>Add this to your <code>~/.bashrc</code> for automatic sourcing: </p><pre><code>echo \"source ~/ros2_ws/install/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre><p></p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that everything is installed correctly:</p> <pre><code># Check if packages are available\nros2 pkg list | grep scara\n\n# Launch the SCARA robot (should open RViz2)\nros2 launch scara_bringup scara.launch.py\n</code></pre> <p>If RViz2 opens with the SCARA robot displayed, your installation is successful! \ud83c\udf89</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#missing-dependencies","title":"Missing Dependencies","text":"<p>If you encounter missing dependencies during build:</p> <pre><code>cd ~/ros2_ws\nrosdep install --from-paths src --ignore-src -y -r --rosdistro jazzy\n</code></pre>"},{"location":"getting-started/installation/#build-errors","title":"Build Errors","text":"<p>If the build fails, try cleaning the workspace and rebuilding:</p> <pre><code>cd ~/ros2_ws\nrm -rf build install log\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Release --symlink-install\n</code></pre>"},{"location":"getting-started/installation/#rviz2-not-opening","title":"RViz2 Not Opening","text":"<p>If RViz2 doesn't open or displays errors:</p> <pre><code># Install RViz2 if missing\nsudo apt install ros-jazzy-rviz2\n\n# Check OpenGL support\nglxinfo | grep \"OpenGL\"\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the ROS2 troubleshooting guide</li> <li>Contact the maintainers (see Contacts)</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that your environment is set up, you can:</p> <ul> <li>Try the Docker setup as an alternative installation method</li> <li>Start with the ros2_control Overview</li> <li>Jump into the URDF Tutorial</li> </ul> <p>Ready to start? Begin with the ros2_control Overview </p>"},{"location":"tutorials/controller_tutorial/","title":"Controller Development","text":""},{"location":"tutorials/controller_tutorial/#writing-of-a-controller","title":"Writing of a Controller","text":"<p>In ros2_control, controllers are implemented as plugins that conforms to the <code>ControllerInterface</code> public interface. Unlike hardware interfaces, controllers are managed node, which means that they work as state-machines and thus have a finite set of states, which are:</p> <ol> <li>Unconfigured</li> <li>Inactive</li> <li>Active</li> <li>Finalized</li> </ol> <p>In order to properly manage controllers, certain interface methods are called when transitions between these states occur. During the main control loop, the controller needs to be in the active state.  In the following development, we will focus on the requirements for writing a new controller interface. For the purpose of this tutorial, the developed controller will be a joint velocity controller taking as input an array of velocities and applying them to each position controlled joint. </p> <p>The controller plugin for the tutorial robot is called <code>ScaraJointVelocityController</code> that inherits from  <code>controller_interface::ControllerInterface</code>. The <code>ScaraJointVelocityController</code> must implement nine public methods. The latter 6 are managed node transition callbacks. 1. <code>command_interface_configuration</code> 2. <code>state_interface_configuration</code> 3. <code>update</code> 4. <code>on_configure</code> 5. <code>on_activate</code> 6. <code>on_deactivate</code> 7. <code>on_cleanup</code> 8. <code>on_error</code> 9. <code>on_shutdown</code></p> <p>These methods are defined in the scara_joint_velocity_controller.hpp header file as follows: </p><pre><code>class ScaraJointVelocityController : public controller_interface::ControllerInterface {\n    public:\n    controller_interface::InterfaceConfiguration command_interface_configuration() const override;\n    controller_interface::InterfaceConfiguration state_interface_configuration() const override;\n    controller_interface::return_type update(const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override;\n    CallbackReturn on_init() override;\n    CallbackReturn on_configure(const rclcpp_lifecycle::State &amp;previous_state) override;\n    CallbackReturn on_activate(const rclcpp_lifecycle::State &amp;previous_state) override;\n    CallbackReturn on_deactivate(const rclcpp_lifecycle::State &amp;previous_state) override;\n    CallbackReturn on_cleanup(const rclcpp_lifecycle::State &amp;previous_state) override;\n    CallbackReturn on_error(const rclcpp_lifecycle::State &amp;previous_state) override;\n    CallbackReturn on_shutdown(const rclcpp_lifecycle::State &amp;previous_state) override;\n// private members\n// ...\n}\n</code></pre><p></p>"},{"location":"tutorials/controller_tutorial/#initializing-the-controller","title":"Initializing the Controller","text":"<p>The <code>on_init</code> method is called immediately after the controller plugin is dynamically loaded. The method is called only once during the lifetime for the controller, hence memory that exists for the lifetime of the controller should be allocated. Additionally, the parameter values for <code>joints</code>, <code>command_interfaces</code> and <code>state_interfaces</code> should be declared and accessed. Those parameter values are required for the next two methods. </p> <p>In this tutorial, in the <code>on_init</code> method the <code>joints</code> parameter is declared as follows: </p><pre><code>CallbackReturn ScaraJointVelocityController::on_init(){\n    // declare and get parameters needed for controller initialization\n    // allocate memory that will exist for the life of the controller\n    // ...\n    auto_declare&lt;std::vector&lt;std::string&gt;&gt;(\"joints\", std::vector&lt;std::string&gt;());\n    return CallbackReturn::SUCCESS;\n}\n</code></pre> This parameter allows to specify the joints that will be controlled with this controller.<p></p>"},{"location":"tutorials/controller_tutorial/#configuring-the-controller","title":"Configuring the Controller","text":"<p>The <code>on_configure</code> method is called immediately after the controller is set to the inactive state. This state occurs when the controller is started for the first time, but also when it is restarted. Reconfigurable parameters should be read in this method. Additionally, publishers and subscribers should be created.</p> <p>In this tutorial, in this method the names of the controlled joints are queried and the subscription to the <code>~/joint_velocity</code> topic is made as follows: </p><pre><code>CallbackReturn ScaraJointVelocityController::on_configure(const rclcpp_lifecycle::State &amp;previous_state){\n    // declare and get parameters needed for controller operations\n    // setup realtime buffers, ROS publishers, and ROS subscribers\n\n    joint_names_ = get_node()-&gt;get_parameter(\"joints\").as_string_array();\n\n    // the desired velocity is queried from the joint_velocity topic\n    // and passed to update via a rt pipe\n    joints_command_subscriber_ = get_node()-&gt;create_subscription&lt;CmdType&gt;(\n        \"~/joint_velocity\", rclcpp::SystemDefaultsQoS(),\n        [this](const CmdType::SharedPtr msg) {rt_command_ptr_.writeFromNonRT(msg);});\n  return CallbackReturn::SUCCESS;\n}\n</code></pre> Notice here that the subscriber callback uses the <code>rt_command_ptr_</code> object to pass the received message. This step is very important as without it the subscriber would block the control loop that needs to be realtime. <p></p> <p>The <code>command_interface_configuration</code>  method is called after <code>on_configure</code>. The method returns a list of <code>InterfaceConfiguration</code> objects to indicate which command interfaces the controller needs to operate. The command interfaces are uniquely identified by their name and interface type. If a requested interface is not offered by a loaded hardware interface, then the controller will fail.</p> <p>In our case, as we want the method to send commands to the position of the joints, the method is defined as follows: </p><pre><code>controller_interface::InterfaceConfiguration ScaraJointVelocityController::command_interface_configuration(){\n    controller_interface::InterfaceConfiguration conf;\n    // add required command interface to `conf` by specifying their names and interface types.\n    conf.names.reserve(joint_names_.size());\n    for (const auto &amp; joint_name : joint_names_) {\n        conf.names.push_back(joint_name + \"/\" + hardware_interface::HW_IF_POSITION);\n    }\n    return conf;\n}\n</code></pre><p></p> <p>The <code>state_interface_configuration</code> method is then called, which is similar to the last method. The difference is that  a list of <code>InterfaceConfiguration</code> objects representing the required state interfaces to operate is returned.</p> <p>Here again, for the purpose of this tutorial we only need the position state. The method is defined as follows:  </p><pre><code>controller_interface::InterfaceConfiguration ScaraJointVelocityController::state_interface_configuration() {\n    controller_interface::InterfaceConfiguration conf;\n    // add required state interface to `conf` by specifying their names and interface types.\n    conf.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n    conf.names.reserve(joint_names_.size());\n    for (const auto &amp; joint_name : joint_names_) {\n        conf.names.push_back(joint_name + \"/\" + hardware_interface::HW_IF_POSITION);\n    }    \n    return conf;\n}\n</code></pre><p></p>"},{"location":"tutorials/controller_tutorial/#activating-the-controller","title":"Activating the Controller","text":"<p>The <code>on_activate</code> is called once when the controller is activated. This method should handle controller restarts, such as setting the resetting reference to safe values. It should also perform controller specific safety checks. The <code>command_interface_configuration</code> and <code>state_interface_configuration</code> are also called again when the controller is activated.</p> <p>In this tutorial, this method is used to order the command interfaces to fit the joint name order of the controller <code>joints</code> parameter. This is done by defining:  </p><pre><code>CallbackReturn ScaraJointVelocityController::on_activate(const rclcpp_lifecycle::State &amp;previous_state){\n  // Handle controller restarts and dynamic parameter updating\n  std::vector&lt;std::reference_wrapper&lt;LoanedCommandInterface&gt;&gt; ordered_interfaces;\n  get_ordered_interfaces(\n      command_interfaces_,\n      joint_names_, \n      hardware_interface::HW_IF_POSITION, \n      ordered_interfaces)\n  return CallbackReturn::SUCCESS;\n}\n</code></pre><p></p>"},{"location":"tutorials/controller_tutorial/#running-the-controller","title":"Running the Controller","text":"<p>The <code>update</code> method is part of the main control loop. Since the method is part of the realtime control loop, the realtime constraint must be enforced. The controller should read from the state interfaces, the reference and compute the command. Normally, the reference is access via a ROS2 subscriber. Since the subscriber runs on the non-realtime thread, a realtime buffer is used to a transfer the message to the realtime thread. The realtime buffer is eventually a pointer to a ROS message with a mutex that guarantees thread safety and that the realtime thread is never blocked. The calculated control command should then be written to the command interface, which will be passed to the hardware.</p> <p>In this tutorial, the <code>update</code> method is defined as follows: </p><pre><code>controller_interface::return_type ScaraJointVelocityController::update(const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period){\n    // Read controller inputs values from state interfaces\n    // Calculate controller output values and write them to command interfaces\n\n    // getting the data from the subscriber using the rt pipe\n    auto joint_velocity = rt_command_ptr_.readFromRT();\n\n    // no command received yet\n    if (!joint_velocity || !(*joint_velocity)) {\n        return controller_interface::return_type::OK;\n    }\n\n    // the states are given in the same order as defines in state_interface_configuration\n    for(auto j = 0ul; j &lt; joint_names_.size(); j++)\n    {   \n        double q = state_interfaces_[j].get_value();\n        double vq = (*joint_velocity)-&gt;data[j];\n\n        double command = q + vq*(period.nanoseconds()*1e-9);\n\n        command_interfaces_[j].set_value(command);\n    }\n\n    return controller_interface::return_type::OK;\n}\n</code></pre> In this method, at first the data is queried from the subscriber using the <code>rt_command_ptr_</code> object. Then we check if a new command was received. Next, the controller iterates over all commanded joints and computes the commanded position to be applied and finally updates the <code>command_interfaces_</code> with the new position that needs to be passed to the hardware. <p></p>"},{"location":"tutorials/controller_tutorial/#additional-methods","title":"Additional methods","text":"<p>The <code>on_deactivate</code> is called when a controller stops running. It is important to release the claimed command interface in this method, so other controllers can use them if needed. This is down with the <code>release_interfaces</code> function.</p> <p>In our case, to keep things simple this method is empty: </p><pre><code>CallbackReturn on_deactivate(const rclcpp_lifecycle::State &amp;previous_state){\n    release_interfaces();\n    // The controller should be properly shutdown during this\n    // ...\n    return CallbackReturn::SUCCESS;\n}\n</code></pre> The <code>on_cleanup</code> and <code>on_shutdown</code> are called when the controller's lifecycle node is transitioning to shutting down. Freeing any allocated memory and general cleanup should be done in these methods. In our case, to keep things simple this methods are also empty: <pre><code>CallbackReturn on_cleanup(const rclcpp_lifecycle::State &amp;previous_state){\n  // Callback function for cleanup transition\n  // ...\n  return CallbackReturn::SUCCESS;\n}\n</code></pre> <pre><code>CallbackReturn on_shutdown(const rclcpp_lifecycle::State &amp;previous_state){\n  // Callback function for shutdown transition\n  // ...\n  return CallbackReturn::SUCCESS;\n}\n</code></pre><p></p> <p>The <code>on_error</code> method is called if the managed node fails a state transition. This should generally never happen.</p> <p>In our case, to keep things simple this method is empty: </p><pre><code>CallbackReturn on_error(const rclcpp_lifecycle::State &amp;previous_state){\n  // Callback function for erroneous transition\n  // ...\n  return CallbackReturn::SUCCESS;\n}\n</code></pre><p></p>"},{"location":"tutorials/controller_tutorial/#building-the-controller-plugin","title":"Building the Controller plugin","text":"<p>Building the Controller plugin is done with the same steps as for the Hardware Interface: * Adding C++ export macro  * Creating the plugin description file * Exporting the CMake library</p>"},{"location":"tutorials/controller_tutorial/#adding-c-export-macro","title":"Adding C++ export macro","text":"<p>In order to reference the previously defined controller as a ros2_control plugin, we need to add the following two lines of code at the end of the scara_joint_velocity_controller.cpp file containing our method definitions:</p> <p></p><pre><code>#include \"pluginlib/class_list_macros.hpp\"\n\nPLUGINLIB_EXPORT_CLASS(scara_joint_velocity_controller::ScaraJointVelocityController, controller_interface::ControllerInterface)\n</code></pre> The <code>PLUGINLIB_EXPORT_CLASS</code> is a c++ macro that creates a plugin library using <code>pluginlib</code>. More information about it can be found here.<p></p>"},{"location":"tutorials/controller_tutorial/#creating-the-plugin-description-file","title":"Creating the plugin description file","text":"<p>The plugin description file is again required for the controller, since it is exported as a library. The controller plugin description file is formatted as follows:</p> <p></p><pre><code>&lt;library path=\"{Library_Name}\"&gt;\n  &lt;class\n    name=\"{Namespace}/{Class_Name}\"\n    type=\"{Namespace}::{Class_Name}\"\n    base_class_type=\"controller_interface::ControllerInterface\"&gt;\n  &lt;description&gt;\n    {Human readable description}\n  &lt;/description&gt;\n  &lt;/class&gt;\n&lt;/library&gt;\n</code></pre>  See here for the complete XML file.<p></p>"},{"location":"tutorials/controller_tutorial/#exporting-the-cmake-library","title":"Exporting the CMake library","text":"<p>The plugin must be specified in the CMake file that builds the controller plugin. </p> <pre><code>add_library(\n    scara_joint_velocity_controller\n    SHARED\n    src/scara_joint_velocity_controller.cpp\n)\n\n# include and link dependencies\n# ...\n\n# Causes the visibility macros to use dllexport rather than dllimport, which is appropriate when building the dll but not consuming it.\ntarget_compile_definitions(scara_joint_velocity_controller PRIVATE \"CONTROLLER_PLUGIN_DLL\")\n# export plugin\npluginlib_export_plugin_description_file(scara_joint_velocity_controller controller_plugin.xml)\n# install libraries\n# ...\n</code></pre> <p>See here for the complete <code>CMakeLists.txt</code> file.</p> <p>Now that the controller is ready to be used, let's add it to the scara_controllers.yaml file and run it on the scara robot! </p> <p>To do so, in the scara_controllers.yaml file add : </p><pre><code>controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    # other controllers\n\n    scara_joint_velocity_controller:\n      type: scara_joint_velocity_controller/ScaraJointVelocityController\n\nscara_joint_velocity_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n\n# other controllers\n</code></pre><p></p> <p>You can now load and interact with the controller as explained in the previous section.</p>"},{"location":"tutorials/ethercat_tutorial/","title":"EtherCAT Integration","text":""},{"location":"tutorials/ethercat_tutorial/#ethercat-tutorial-using-ethercat_driver_ros2-with-cia-402-drives","title":"EtherCAT Tutorial: Using ethercat_driver_ros2 with CIA 402 Drives","text":"<p>This tutorial provides a comprehensive guide to using the <code>ethercat_driver_ros2</code> stack to integrate EtherCAT-based CIA 402 drives with ROS 2 and ros2_control.</p> <p>What You'll Learn</p> <ul> <li>How to install and configure ethercat_driver_ros2</li> <li>Understanding CIA 402 drive protocol and state machine</li> <li>Configuring EtherCAT slaves with YAML files</li> <li>Integrating drives into URDF with ros2_control</li> <li>Controlling real EtherCAT hardware</li> </ul>"},{"location":"tutorials/ethercat_tutorial/#introduction","title":"Introduction","text":""},{"location":"tutorials/ethercat_tutorial/#what-is-ethercat_driver_ros2","title":"What is ethercat_driver_ros2?","text":"<p>The <code>ethercat_driver_ros2</code> stack provides a bridge between EtherCAT devices and ROS 2's ros2_control framework. It enables:</p> <ul> <li>Real-time communication with EtherCAT modules</li> <li>Generic plugin architecture for different device types</li> <li>Seamless integration with ros2_control Hardware Interfaces</li> <li>Support for CIA 402 compliant motor drives</li> </ul> <p>Resources</p> <ul> <li>Repository: ICube-Robotics/ethercat_driver_ros2</li> <li>Documentation: https://icube-robotics.github.io/ethercat_driver_ros2/</li> </ul>"},{"location":"tutorials/ethercat_tutorial/#what-is-cia-402","title":"What is CIA 402?","text":"<p>CIA 402 (CANopen device profile for drives and motion control) is a standardized protocol for controlling motor drives. The <code>EcCiA402Drive</code> plugin implements this standard for EtherCAT-based drives, providing:</p> <ul> <li>Automatic state machine management (Switched On, Operation Enabled, etc.)</li> <li>Multiple modes of operation: Position (8), Velocity (9), Effort/Torque (10), Homing (6)</li> <li>Fault handling with automatic or manual reset</li> <li>Safe default behavior to prevent unwanted movements</li> </ul>"},{"location":"tutorials/ethercat_tutorial/#installation","title":"Installation","text":""},{"location":"tutorials/ethercat_tutorial/#1-install-igh-ethercat-master","title":"1. Install IgH EtherCAT Master","text":"<p>Follow installation steps here</p>"},{"location":"tutorials/ethercat_tutorial/#2a-install-ethercat_driver_ros2","title":"2a. Install ethercat_driver_ros2","text":"<p>Create a ROS 2 workspace and clone the repository:</p> <pre><code># Create workspace\nmkdir -p ~/ros2_ethercat_ws/src\ncd ~/ros2_ethercat_ws/src\n\n# Clone the repository (jazzy branch)\ngit clone -b jazzy https://github.com/ICube-Robotics/ethercat_driver_ros2.git\n\n# Install dependencies\ncd ~/ros2_ethercat_ws\nrosdep install --from-paths src --ignore-src -r -y\n\n# Build the workspace\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Release\n\n# Source the workspace\nsource install/setup.bash\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#2b-using-docker","title":"2b. Using Docker","text":"<p>Provides a basic preconfigured docker container for tutorial purposes.</p> <p>To use it, make sure you have Docker installed, then run the image :</p> <pre><code>$ docker run --device=/dev/EtherCAT0:/dev/EtherCAT0 mc3ed/ecat_ros2_workshop:jazzy ros2 launch scara_bringup scara_ecat.launch.py\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#run-with-gui","title":"Run with GUI","text":"<p>To run the docker image with GUI, use the rocker tool: </p><pre><code>$ sudo apt install python3-rocker\n$ rocker --net=host --x11 --devices /dev/dri --device=/dev/EtherCAT0:/dev/EtherCAT0 --user mc3ed/ecat_ros2_workshop:jazzy ros2 launch scara_bringup scara_ecat.launch.py\n</code></pre><p></p>"},{"location":"tutorials/ethercat_tutorial/#run-with-novnc","title":"Run with noVNC","text":"<p>To run the docker image with noVNC, run the novnc docker : </p><pre><code>$ docker run --rm -p 6080:6080 --device=/dev/EtherCAT0:/dev/EtherCAT0 -it mc3ed/ecat_ros2_workshop:jazzy_novnc\n</code></pre> Then open your browser and navigate to <code>http://localhost:6080/vnc.html</code> to access the desktop environment. Inside the noVNC session, you can open a terminal and run: <pre><code>$ cd ros2_dev/ecat_ros2_workshop/\n$ source install/setup.bash\n$ ros2 launch scara_bringup scara.launch.py\n</code></pre><p></p> <p>Note for Intel integrated graphics: The <code>--devices /dev/dri</code> flag is required to mount the Direct Rendering Infrastructure, which enables hardware-accelerated graphics for rviz2.</p>"},{"location":"tutorials/ethercat_tutorial/#run-with-bash","title":"Run with bash","text":"<p>To interact with the environment, run docker using: </p><pre><code>$ docker run -it mc3ed/ecat_ros2_workshop:jazzy\n</code></pre> and inside docker run: <pre><code>$ cd ros2_dev/ecat_ros2_workshop/\n$ source install/setup.bash\n$ ros2 launch scara_bringup scara.launch.py\n</code></pre> The <code>ecat_ros2_workshop</code> nodes should now be running.<p></p>"},{"location":"tutorials/ethercat_tutorial/#understanding-cia-402-drives","title":"Understanding CIA 402 Drives","text":""},{"location":"tutorials/ethercat_tutorial/#state-machine","title":"State Machine","text":"<p>CIA 402 drives follow a standardized state machine:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; SwitchOnDisabled\n    SwitchOnDisabled --&gt; ReadyToSwitchOn\n    ReadyToSwitchOn --&gt; SwitchedOn\n    SwitchedOn --&gt; OperationEnabled\n    OperationEnabled --&gt; [*]\n</code></pre> <p>The <code>EcCiA402Drive</code> plugin automatically manages these transitions, bringing the drive to <code>OPERATION_ENABLED</code> state by default.</p>"},{"location":"tutorials/ethercat_tutorial/#modes-of-operation","title":"Modes of Operation","text":"Mode Value Description Cyclic Sync Position 8 Real-time position control (most common) Cyclic Sync Velocity 9 Real-time velocity control Cyclic Sync Torque 10 Real-time torque control Homing 6 Automatic homing procedure"},{"location":"tutorials/ethercat_tutorial/#configuration","title":"Configuration","text":""},{"location":"tutorials/ethercat_tutorial/#step-1-create-a-slave-configuration-file","title":"Step 1: Create a Slave Configuration File","text":"<p>Create a YAML file to configure your EtherCAT drive. Example for Maxon EPOS3:</p> config/maxon_epos3.yaml<pre><code># Configuration file for Maxon EPOS3 drive\nvendor_id: 0x000000fb\nproduct_id: 0x64400000\nassign_activate: 0x0300  # DC Synch register\nauto_fault_reset: false  # Manual fault reset\n\n# SDO configuration at startup\nsdo:\n  - {index: 0x60C2, sub_index: 1, type: int8, value: 10}  # Interpolation time: 10 ms\n  - {index: 0x60C2, sub_index: 2, type: int8, value: -3}  # Time base: 10^-3s\n\n# RxPDO Mapping (Master \u2192 Slave)\nrpdo:\n  - index: 0x1603\n    channels:\n      - {index: 0x6040, sub_index: 0, type: uint16, default: 0}  # Control word\n      - {index: 0x607a, sub_index: 0, type: int32, command_interface: position, default: .nan}\n      - {index: 0x60ff, sub_index: 0, type: int32, default: 0}  # Target velocity\n      - {index: 0x6071, sub_index: 0, type: int16, default: 0}  # Target torque\n      - {index: 0x6060, sub_index: 0, type: int8, default: 8}   # Mode: Cyclic Sync Position\n\n# TxPDO Mapping (Slave \u2192 Master)\ntpdo:\n  - index: 0x1a03\n    channels:\n      - {index: 0x6041, sub_index: 0, type: uint16}  # Status word\n      - {index: 0x6064, sub_index: 0, type: int32, state_interface: position}\n      - {index: 0x606c, sub_index: 0, type: int32, state_interface: velocity}\n      - {index: 0x6077, sub_index: 0, type: int16, state_interface: effort}\n      - {index: 0x6061, sub_index: 0, type: int8}    # Mode display\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#key-configuration-elements","title":"Key Configuration Elements","text":""},{"location":"tutorials/ethercat_tutorial/#vendor_id-and-product_id","title":"vendor_id and product_id","text":"<p>Find these using:</p> <pre><code>ethercat slaves\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#pdo-mapping","title":"PDO Mapping","text":"<p>RxPDO (Master \u2192 Slave): Commands sent to the drive</p> <ul> <li><code>command_interface</code>: Maps to ros2_control command interfaces</li> <li><code>default</code>: Default value when not actively controlled</li> </ul> <p>TxPDO (Slave \u2192 Master): Feedback from the drive</p> <ul> <li><code>state_interface</code>: Maps to ros2_control state interfaces</li> </ul>"},{"location":"tutorials/ethercat_tutorial/#urdf-integration","title":"URDF Integration","text":""},{"location":"tutorials/ethercat_tutorial/#basic-configuration","title":"Basic Configuration","text":"<p>Integrate the EtherCAT drive into your robot's URDF:</p> ros2_control/robot.ros2_control.urdf<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"my_robot\"&gt;\n\n  &lt;ros2_control name=\"ethercat_system\" type=\"system\"&gt;\n    &lt;hardware&gt;\n      &lt;plugin&gt;ethercat_driver/EthercatDriver&lt;/plugin&gt;\n      &lt;param name=\"master_id\"&gt;0&lt;/param&gt;\n      &lt;param name=\"control_frequency\"&gt;100&lt;/param&gt;\n    &lt;/hardware&gt;\n\n    &lt;!-- Joint configuration --&gt;\n    &lt;joint name=\"joint_1\"&gt;\n      &lt;state_interface name=\"position\"/&gt;\n      &lt;state_interface name=\"velocity\"/&gt;\n      &lt;state_interface name=\"effort\"/&gt;\n      &lt;command_interface name=\"position\"/&gt;\n      &lt;command_interface name=\"reset_fault\"/&gt;\n\n      &lt;ec_module name=\"Joint1_Drive\"&gt;\n        &lt;plugin&gt;ethercat_generic_plugins/EcCiA402Drive&lt;/plugin&gt;\n        &lt;param name=\"alias\"&gt;0&lt;/param&gt;\n        &lt;param name=\"position\"&gt;0&lt;/param&gt;\n        &lt;param name=\"mode_of_operation\"&gt;8&lt;/param&gt;\n        &lt;param name=\"slave_config\"&gt;/path/to/maxon_epos3.yaml&lt;/param&gt;\n      &lt;/ec_module&gt;\n    &lt;/joint&gt;\n\n  &lt;/ros2_control&gt;\n\n&lt;/robot&gt;\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#multi-joint-configuration","title":"Multi-Joint Configuration","text":"<p>For robots with multiple joints, add more joint definitions with incremented positions:</p> <pre><code>&lt;joint name=\"joint_2\"&gt;\n  &lt;!-- ... interfaces ... --&gt;\n  &lt;ec_module name=\"Joint2_Drive\"&gt;\n    &lt;plugin&gt;ethercat_generic_plugins/EcCiA402Drive&lt;/plugin&gt;\n    &lt;param name=\"alias\"&gt;0&lt;/param&gt;\n    &lt;param name=\"position\"&gt;1&lt;/param&gt;  &lt;!-- Next position on bus --&gt;\n    &lt;param name=\"mode_of_operation\"&gt;8&lt;/param&gt;\n    &lt;param name=\"slave_config\"&gt;/path/to/drive_config.yaml&lt;/param&gt;\n  &lt;/ec_module&gt;\n&lt;/joint&gt;\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#launch-and-usage","title":"Launch and Usage","text":""},{"location":"tutorials/ethercat_tutorial/#start-ethercat-master","title":"Start EtherCAT Master","text":"<pre><code>sudo systemctl start ethercat\n</code></pre> <p>Verify slaves are detected:</p> <pre><code>ethercat slaves\n</code></pre> <p>Expected output: </p><pre><code>0  0:0  PREOP  +  MAXON EPOS3 70/10 EtherCAT\n</code></pre><p></p>"},{"location":"tutorials/ethercat_tutorial/#launch-your-robot","title":"Launch Your Robot","text":"<p>Create a launch file similar to the SCARA tutorial, but ensure you run with real-time priority:</p> <pre><code>control_node = Node(\n    package=\"controller_manager\",\n    executable=\"ros2_control_node\",\n    parameters=[robot_description, robot_controllers],\n    output=\"both\",\n    # Run with real-time priority\n    prefix=['sudo -E env \"PATH=$PATH\" chrt -f 95'],\n)\n</code></pre> <p>Launch your robot:</p> <pre><code>ros2 launch my_robot_bringup robot_ethercat.launch.py\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#send-commands","title":"Send Commands","text":"<p>Use standard ros2_control interfaces to command your robot:</p> <pre><code># Check controller status\nros2 control list_controllers\n\n# Send position command\nros2 topic pub /joint_trajectory_controller/joint_trajectory \\\n  trajectory_msgs/msg/JointTrajectory \\\n  \"{joint_names: ['joint_1'], points: [{positions: [0.5], time_from_start: {sec: 2}}]}\" \\\n  --once\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#advanced-topics","title":"Advanced Topics","text":""},{"location":"tutorials/ethercat_tutorial/#fault-handling","title":"Fault Handling","text":""},{"location":"tutorials/ethercat_tutorial/#manual-fault-reset","title":"Manual Fault Reset","text":"<p>When <code>auto_fault_reset: false</code>:</p> <pre><code># Trigger fault reset via rising edge\nros2 service call /controller_manager/set_hardware_component_state \\\n  controller_manager_msgs/srv/SetHardwareComponentState \\\n  \"{name: 'ethercat_system', target_state: {id: 3, label: 'active'}}\"\n</code></pre>"},{"location":"tutorials/ethercat_tutorial/#mode-switching","title":"Mode Switching","text":"<p>Switch between position, velocity, and torque control dynamically by:</p> <ol> <li>Defining multiple command interfaces in URDF</li> <li>Using mode-switching controllers</li> <li>Sending <code>NaN</code> to unused interfaces when switching</li> </ol>"},{"location":"tutorials/ethercat_tutorial/#real-time-performance","title":"Real-Time Performance","text":"<p>For optimal real-time performance:</p> <ol> <li>Install PREEMPT_RT kernel</li> <li>Set real-time priorities in launch file</li> <li>Optimize control frequency (100-1000 Hz)</li> <li>Isolate CPU cores for real-time tasks</li> </ol>"},{"location":"tutorials/ethercat_tutorial/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Slave not detected Check <code>ethercat config</code> and network interface Permission denied Add user to ethercat group: <code>sudo usermod -aG ethercat $USER</code> Drive stays in fault Check wiring, power, and config file Position drift Set <code>default: .nan</code> for target position in config"},{"location":"tutorials/ethercat_tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Experiment with different control modes</li> <li>Optimize configuration for your hardware</li> <li>Explore the developer guide</li> </ul>"},{"location":"tutorials/ethercat_tutorial/#additional-resources","title":"Additional Resources","text":"<ul> <li>Generic EtherCAT Slave Configuration</li> <li>CANopen over EtherCAT</li> <li>API Reference</li> </ul> <p>Happy controlling! \ud83e\udd16</p>"},{"location":"tutorials/fsoe_tutorial/","title":"FSoE Safety Protocol","text":""},{"location":"tutorials/fsoe_tutorial/#fsoe-fail-safe-over-ethercat-safety-in-industrial-communication","title":"FSoE (Fail-Safe over EtherCAT): Safety in Industrial Communication","text":""},{"location":"tutorials/fsoe_tutorial/#introduction-to-fsoe","title":"Introduction to FSoE","text":"<p>Fail-Safe over EtherCAT (FSoE) is a safety protocol designed to enable the transmission of safety-critical data alongside standard process data on the same EtherCAT network. FSoE leverages the Black Channel principle, ensuring that safety is managed at the protocol level rather than the physical medium. This approach allows EtherCAT networks to achieve SIL 3 (Safety Integrity Level 3), making it suitable for applications where human safety is critical, such as robotics, industrial automation, and medical devices.</p> <p>FSoE is T\u00dcV-certified and complies with international standards such as IEC 61508 and IEC 61784-3. It is maintained as an open technology by the EtherCAT Technology Group (ETG).</p>"},{"location":"tutorials/fsoe_tutorial/#fsoe-basics-and-frame-structure","title":"FSoE Basics and Frame Structure","text":"<p>[IMAGE PLACEHOLDER: FSoE Basics and Frame Structure] Caption: Illustration of the FSoE frame structure, showing how safety data is embedded within standard EtherCAT frames.</p> <p>FSoE embeds safety data within standard EtherCAT frames, adding integrity information such as Cyclic Redundancy Checks (CRC), watchdog timers, and connection IDs. Each FSoE frame includes:</p> <ul> <li>Command (CMD): Specifies the type of safety command.</li> <li>Safe Data: Contains safety-related information, such as the status of an emergency stop.</li> <li>CRC_0 and CRC_1: Used to detect errors in the transmitted data.</li> <li>Connection ID: Ensures data is sent to and received from the correct devices.</li> </ul> <p>The minimum FSoE frame length is 6 bytes, but there is no strict upper limit on the size of the safe data. Each 2-byte block of safe data is protected by a 2-byte CRC, ensuring robust error detection.</p>"},{"location":"tutorials/fsoe_tutorial/#network-topologies-with-fsoe","title":"Network Topologies with FSoE","text":"<p>FSoE supports multiple network topologies, each with unique advantages and use cases.</p>"},{"location":"tutorials/fsoe_tutorial/#centralized-approach","title":"Centralized Approach","text":"<p>[IMAGE PLACEHOLDER: Centralized FSoE Topology] Caption: Diagram of a centralized FSoE topology, where the FSoE Master is integrated into the EtherCAT Master device.</p> <p>In a centralized approach, the FSoE Master is integrated into the EtherCAT Master device. This simplifies the system architecture by eliminating the need for SubDevice-to-SubDevice communication. However, the EtherCAT Master device must be safety-certified, which can increase costs and complexity.</p> <p>Advantages: - Simplified configuration. - Direct control over all safety functions.</p> <p>Drawbacks: - The EtherCAT Master device must be safety-certified. - Single point of failure.</p> <p>Status in <code>ethercat_driver_ros2</code>: The centralized approach is not currently implemented in the <code>ethercat_driver_ros2</code> package.</p>"},{"location":"tutorials/fsoe_tutorial/#decentralized-safety-logic","title":"Decentralized Safety Logic","text":"<p>[IMAGE PLACEHOLDER: Decentralized FSoE Topology] Caption: Diagram of a decentralized FSoE topology, showing the FSoE MainInstance on a separate SubDevice and its communication with other SubInstances.</p> <p>In a decentralized approach, the FSoE MainInstance runs on a separate EtherCAT SubDevice. This allows the EtherCAT Master device to remain non-certified, simplifying design and reducing costs. Multiple FSoE SubInstances (e.g., safe I/O modules, drives) communicate with the FSoE MainInstance via the EtherCAT Master device.</p> <p>Advantages: - No certification required for the EtherCAT Master device. - Modularity and fault isolation.</p> <p>Use Cases: - Safety I/O modules (e.g., emergency stops, safety gates). - Safe drives and motion control (e.g., STO, SS1, SS2). - Modular machines with distributed safety devices.</p>"},{"location":"tutorials/fsoe_tutorial/#communication-mechanism-in-fsoe","title":"Communication Mechanism in FSoE","text":"<p>FSoE ensures reliable transmission of safety data through logical safety connections between the FSoE MainInstance and SubInstances. Safety frames are exchanged via standard EtherCAT process data, and the EtherCAT Master device must support data copying for SubDevice-to-SubDevice communication.</p>"},{"location":"tutorials/fsoe_tutorial/#copy-infos-configuration-file","title":"Copy Infos Configuration File","text":"<p>[IMAGE PLACEHOLDER: ENI Configuration Example] Caption: Example of an ENI (EtherCAT Network Information) configuration file, showing how data copying is configured for SubDevice-to-SubDevice communication.</p> <p>The ENI (EtherCAT Network Information) file defines the source, destination, and size of data blocks for SubDevice-to-SubDevice communication. The <code>ethercat_driver_ros2</code> software processes these entries to ensure safety data is routed correctly.</p>"},{"location":"tutorials/fsoe_tutorial/#role-of-maindevice-software-ethercat_driver_ros2","title":"Role of MainDevice Software (<code>ethercat_driver_ros2</code>)","text":"<p>The MainDevice, running <code>ethercat_driver_ros2</code>, acts as part of the Black Channel and does not need to be safety-certified. It facilitates the transmission of safety data by:</p> <ul> <li>Reading process-data input.</li> <li>Performing data copying based on ENI rules.</li> <li>Writing process-data output.</li> </ul> <p>This ensures seamless communication between the FSoE MainInstance and SubInstances.</p>"},{"location":"tutorials/fsoe_tutorial/#safety-cycle-in-decentralized-mode","title":"Safety Cycle in Decentralized Mode","text":"<p>The safety cycle in a decentralized FSoE system involves:</p> <ol> <li>The FSoE MainInstance sends a safety \"MainInstance Frame\" to SubInstances.</li> <li>SubInstances reply with their \"SubInstance Frames.\"</li> <li>Safety checks, including CRC validation, connection ID verification, and watchdog timers, are performed.</li> </ol> <p>This cycle ensures reliable transmission of safety data and prompt detection of errors or failures.</p>"},{"location":"tutorials/fsoe_tutorial/#advantages-and-use-cases-of-decentralized-fsoe","title":"Advantages and Use Cases of Decentralized FSoE","text":"<p>The decentralized approach offers several advantages:</p> <ul> <li>The EtherCAT Master device does not need to be safety-certified.</li> <li>Modularity and fault isolation improve system resilience.</li> <li>Use Cases:</li> <li>Safety I/O modules (e.g., emergency stops, safety gates).</li> <li>Safe drives and motion control (e.g., STO, SS1, SS2).</li> <li>Modular machines with distributed safety devices.</li> </ul>"},{"location":"tutorials/fsoe_tutorial/#configuration-of-fsoe-devices","title":"Configuration of FSoE Devices","text":"<p>Configuring FSoE devices involves:</p> <ol> <li>Assigning FSoE Device Addresses: Using hardware DIP switches or software tools.</li> <li>Defining Safety Logic: Using manufacturer tools like Beckhoff TwinSAFE with TwinCAT.</li> <li>Mapping Safety Inputs and Outputs: Connecting safety signals to logical variables.</li> <li>Establishing Logical Connections: Between the FSoE MainInstance and SubInstances.</li> <li>Configuring SubDevice-to-SubDevice Communication: Using the ENI file.</li> </ol>"},{"location":"tutorials/fsoe_tutorial/#conclusion","title":"Conclusion","text":"<p>FSoE (Fail-Safe over EtherCAT) provides a robust solution for transmitting safety-critical data in industrial applications. Its support for both centralized and decentralized topologies, combined with the flexibility of the <code>ethercat_driver_ros2</code> package, makes it an ideal choice for modern robotics and automation systems. Future developments will focus on enhancing multi-master redundancy, hot-plug support, and user-friendly configuration tools.</p>"},{"location":"tutorials/gazebo_tutorial/","title":"Gazebo Simulation","text":""},{"location":"tutorials/gazebo_tutorial/#setting-up-the-scara-manipulator-to-run-with-ros2_control-and-gazebo","title":"Setting up the SCARA manipulator to run with ros2_control and Gazebo","text":"<p>Whereas using simulated hardware is very important to test the kinematic properties of the robot, in many application the use of robot dynamics and interactions with the environment is required. The Gazebo simulator is often used in ROS2 projects as it easy to combine ROS2 with Gazebo. Also, ros2_control has specific Hardware Interfaces that allow to simulate a hardware inside Gazebo while using controllers in the ros2_control framework. </p> <p>In this section of the tutorial, we will focus on how to simulate the SCARA robot in Gazebo with ros2_control and how to interact with it. </p>"},{"location":"tutorials/gazebo_tutorial/#adding-the-gazebo-description-to-the-urdf","title":"Adding the Gazebo description to the URDF","text":"<p>In order to use ros2_control with Gazebo, some additional setup steps are required in the robot description. In fact, Gazebo allows to implement Gazebo plugins to interact with the simulation, what is used to create a bridge between Gazebo and ros2_control. The <code>gazebo_ros2_control</code> plugin is used for this reason. In contrary to the previous steps where the Controller Manager was acting as a standalone ROS2 node, in this case the <code>gazebo_ros2_control</code> plugin is responsible of running an instance of the Controller Manager inside the Gazebo node.   </p> <p>This can be done by adding a <code>scara.gazebo.xacro</code> configuration file in the <code>scara_description</code> package, that contains:</p> <p></p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"scara\"&gt;\n    &lt;!-- ros_control plugin --&gt;\n    &lt;gazebo&gt;\n      &lt;plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"&gt;\n        &lt;parameters&gt;$(find scara_description)/config/scara_controllers.yaml&lt;/parameters&gt;\n        &lt;robot_param_node&gt;robot_state_publisher&lt;/robot_param_node&gt;\n      &lt;/plugin&gt;\n    &lt;/gazebo&gt;\n    &lt;!-- Used for fixing robot --&gt;\n    &lt;gazebo reference=\"world\"&gt;\n        &lt;static&gt;true&lt;/static&gt;\n    &lt;/gazebo&gt;\n\n    &lt;!-- color --&gt;\n    &lt;gazebo reference=\"base_link\"&gt;\n      &lt;material&gt;Gazebo/Blue&lt;/material&gt;\n    &lt;/gazebo&gt;\n\n    &lt;!-- materials for other links --&gt;\n\n&lt;/robot&gt;\n</code></pre> In this description file, the <code>gazebo</code> tags are used to specify parameters to be used by Gazebo and in particular the <code>plugin</code> that needs to be loaded. The plugin here is the <code>gazebo_ros2_control</code> plugin contained in the <code>libgazebo_ros2_control.so</code> library. This plugin takes 2 parameters in the same way as the ControllerManager before, which are the <code>scara_controllers.yaml</code> configuration file and the name of the node that published the <code>robot_description</code> topic, which is by default done by the <code>robot_state_publisher</code> node. The <code>gazebo</code> tags are also used to add additional gazebo parameters to already defined objects. Here we use them to fix the robot to a static world frame and to add a color to each link. <p></p> <p>This description file can then be added to the <code>scara.config.xacro</code> by adding: </p><pre><code>&lt;!-- Import all Gazebo-customization elements --&gt;\n&lt;xacro:include filename=\"$(find scara_description)/gazebo/scara.gazebo.xacro\"/&gt;\n</code></pre><p></p>"},{"location":"tutorials/gazebo_tutorial/#adding-the-gazebo-ros2_control-hardware-interface","title":"Adding the Gazebo ros2_control Hardware Interface","text":"<p>Now that the ros2_control plugin was added to the description, we also need to specify the ros2_control Hardware Interface that needs to be used to link the Gazebo hardware with ros2_control. To do so we just need to specify the <code>GazeboSystem</code> hardware interface plugin in the ros2_control urdf description file as follows: </p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name = \"scara\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n    &lt;ros2_control name=\"scara\" type=\"system\"&gt;\n        &lt;hardware&gt;\n            &lt;plugin&gt;gazebo_ros2_control/GazeboSystem&lt;/plugin&gt;\n        &lt;/hardware&gt;\n    &lt;!-- joints, gpios, sensors --&gt;\n    &lt;/ros2_control&gt;\n&lt;/robot&gt;\n</code></pre><p></p>"},{"location":"tutorials/gazebo_tutorial/#launching-gazebo-with-ros2_control","title":"Launching Gazebo with ros2_control","text":"<p>Once the description is complete, we need to modify the launch file so that it can launch Gazebo and spawn the robot from the URDF description. </p> <p>The Gazebo node has its own launch file that can be included in our launch file as follows:  </p><pre><code>gazebo = IncludeLaunchDescription(\n    PythonLaunchDescriptionSource(\n        [PathJoinSubstitution(\n            [FindPackageShare('gazebo_ros'),\n                'launch', 'gazebo.launch.py']\n        )]\n    ),\n    launch_arguments={'verbose': 'false'}.items(),\n)\n</code></pre><p></p> <p>To spawn the robot from its description to Gazebo a dedicated spawner node is available and can be called as follows: </p><pre><code>spawn_entity = Node(\n    package='gazebo_ros',\n    executable='spawn_entity.py',\n    arguments=['-topic', robot_description, '-entity', 'scara'],\n    output='screen',\n)\n</code></pre> The arguments that are given here are: * The <code>topic</code> parameter, specifying the topic name in which the robot description is published. This topic is usually published by the <code>robot_state_publisher</code> node. * The <code>entity</code> parameter, specifying the name of the robot to be spawned as given in the URDF description.<p></p> <p>See the <code>scara_gazebo.launch.py</code> file for the complete launch file.</p> <p>Notice that because the Controller Manager is already running inside the Gazebo node, it will not be launched here. </p> <p>You can now run the launch file using:  </p><pre><code>$ ros2 launch scara_bringup scara_gazebo.launch.py \n</code></pre> You should have Gazebo displaying the scara robot running as a Gazebo ros2_control hardware <p></p> <p>You can now load and interact with it as explained in the previous section.</p>"},{"location":"tutorials/hardware_tutorial/","title":"Hardware Interface","text":""},{"location":"tutorials/hardware_tutorial/#writing-of-a-hardware-interface","title":"Writing of a Hardware Interface","text":"<p>In the case if the hardware interface is not available or not suited for the desired application, it can be developed in a custom way, what is the topic of the next section.</p> <p>In ros2_control, hardware system components are integrated via user defined driver plugins that conform to the <code>HarwareInterface</code> public interface. Hardware plugins specified in the URDF are dynamically loaded during initialization using the <code>pluginlib</code> interface. More information about creating and using plugins can be found here.</p> <p>For the purpose of this tutorial, let's create the custom interface plugin <code>ScaraRobot</code> that will be used to simulate a scara robot. We want the simulated system to be controlled in joint position and provide information about its current position and velocity, as described in the ros2_control description file.  </p> <p>To do so, in the <code>scara_hardware</code> package, let's first define the hardware plugin called <code>ScaraRobot</code> that inherits from  <code>hardware_interface::SystemInterface</code>. The <code>SystemInterface</code> is one of the offered hardware interfaces designed for a complete robot system. For example, The UR5 uses this interface. The <code>ScaraRobot</code> must implement five public methods: 1. <code>on_init</code> 2. <code>export_state_interfaces</code> 3. <code>export_command_interfaces</code> 4. <code>read</code> 5. <code>write</code></p> <p>These methods are defined in the scara_robot.hpp header file as follows: </p> <pre><code>using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;\n#include \"hardware_interface/types/hardware_interface_return_values.hpp\"\n\nclass HARDWARE_INTERFACE_PUBLIC ScaraRobot : public hardware_interface::SystemInterface {\n    public:\n    CallbackReturn on_init(const hardware_interface::HardwareInfo &amp;info) override;\n    std::vector&lt;hardware_interface::StateInterface&gt; export_state_interfaces() override;\n    std::vector&lt;hardware_interface::CommandInterface&gt; export_command_interfaces() override;\n    return_type read(const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override;\n    return_type write(const rclcpp::Time &amp; /*time*/, const rclcpp::Duration &amp; /*period*/) override;\n    // private members\n    // ...\n}\n</code></pre>"},{"location":"tutorials/hardware_tutorial/#initializing-the-hardware","title":"Initializing the hardware","text":"<p>Let's first have a look at the initialization <code>on_init</code> method. The <code>on_init</code> method is called once during ros2_control initialization if the <code>ScaraRobot</code> was specified in the URDF. This method should: - Check the validity of the requested <code>command_interfaces</code> and <code>state_interfaces</code> w.r.t. the loaded driver - Instantiate the communication with the robot hardware - Allocate memory</p> <p>Since in this tutorial the robot is simulated, no communication need to be established. Instead, vectors will be initialized that represent the state all the hardware using the initial values from the description file. The definition of this method is as follows: </p> <p></p><pre><code>CallbackReturn ScaraRobot::on_init(const hardware_interface::HardwareInfo &amp;info) {\n    if (hardware_interface::SystemInterface::on_init(info) != CallbackReturn::SUCCESS) {\n        return CallbackReturn::ERROR;\n    }\n\n    // allocate memory \n    hw_states_position_.resize(info_.joints.size() std::numeric_limits&lt;double&gt;::quiet_NaN());\n    //...\n    // check the validity of the description\n    for (const hardware_interface::ComponentInfo &amp; joint : info_.joints) {\n        if (joint.command_interfaces[0].name != hardware_interface::HW_IF_POSITION)\n        {\n            return CallbackReturn::ERROR;\n        }\n    }\n    // ...\n    // initialize states\n    for (uint i = 0; i &lt; info_.joints.size(); i++) {\n        hw_states_position_[i] = std::stod(info_.joints[i].state_interfaces[0].initial_value);\n    }\n    // ...\n    return CallbackReturn::SUCCESS;\n}\n</code></pre> Note that the behavior of <code>on_init</code> is expected to vary depending on the URDF description file. The <code>SystemInterface::on_init(info)</code> call fills out the <code>info</code> object with specifics from the URDF. The <code>info</code> object has fields for joints, sensors, gpios, and more. This allows to check if the interface that is called is compatible with the description and use to parameters from the description file to set up the hardware. <p></p>"},{"location":"tutorials/hardware_tutorial/#exporting-interfaces","title":"Exporting interfaces","text":"<p>Next, <code>export_state_interfaces</code> and <code>export_command_interfaces</code> methods are called in succession. Their purpose is to create a handle to link the internal state/command variable with the ros2_control framework so that it can be accessed from any method. The <code>export_state_interfaces</code> method returns a vector of <code>StateInterface</code> describing the <code>state_interfaces</code> for each joint. The <code>StateInterface</code> objects are read only data handles that contain the interface name, interface type, and a pointer to a double data value of the internal state variable. For the <code>ScaraRobot</code>, the <code>export_state_interfaces</code> references <code>hw_states_position_</code> vector with the position state interface and is defined as follows:  </p><pre><code>std::vector&lt;hardware_interface::StateInterface&gt; ScaraRobot::export_state_interfaces() {\n    std::vector&lt;hardware_interface::StateInterface&gt; state_interfaces;\n    for (uint i = 0; i &lt; info_.joints.size(); i++) {\n        state_interfaces.emplace_back(\n            hardware_interface::StateInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_POSITION, &amp;hw_states_position_[i]));\n    }\n    // ...\n    return state_interfaces;\n}\n</code></pre> The <code>export_command_interfaces</code> method is nearly identical to the previous one. The difference is that a vector of <code>CommandInterface</code> is returned. The vector contains objects describing the <code>command_interfaces</code> for each joint. For the <code>ScaraRobot</code>, the <code>export_command_interfaces</code> references the <code>hw_commands_position_</code> vector with the position command interface and is defined as follows:  <pre><code>std::vector&lt;hardware_interface::CommandInterface&gt; ScaraRobot::export_command_interfaces() {\n    std::vector&lt;hardware_interface::CommandInterface&gt; command_interfaces;\n    for (uint i = 0; i &lt; info_.joints.size(); i++) {\n        command_interfaces.emplace_back(\n            hardware_interface::CommandInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_POSITION, &amp;hw_commands_position_[i]));\n    }\n    return command_interfaces;\n}\n</code></pre> Now that the Hardware Interface is initialized, connected to the robot and that the internal variables are connected to the ros2_control framework, let's focus on the main control loop. <p></p>"},{"location":"tutorials/hardware_tutorial/#reading-and-writing-from-the-hardware","title":"Reading and writing from the hardware","text":"<p>In ros2_control the main control loop consists in successive calls of the hardware <code>read</code> method, followed by the controller <code>update</code> method, followed by the hardware <code>write</code> method. In the read phase of the main loop, ros2_control loops over all hardware components that where loaded to call their <code>read</code> method. It is executed on the realtime thread, hence the method must obey by realtime constraints. The <code>read</code> method is responsible for accessing the robot current state and updating the data values of the <code>state_interfaces</code>.  In this tutorial, as we only want to simulate the robot, we compute its current velocity as follows: </p><pre><code>hardware_interface::return_type ScaraRobot::read(const rclcpp::Time &amp; time, const rclcpp::Duration &amp;period) {\n    // read hardware values for state interfaces, e.g joint encoders and sensor readings\n    for (uint i = 0; i &lt; info_.joints.size(); i++) {\n        hw_states_velocity_[i] = (hw_states_position_[i] - hw_states_previous_position_[i])/(period.nanoseconds()*1e-9);\n\n        hw_states_previous_position_[i] = hw_states_position_[i];\n    }\n    return hardware_interface::return_type::OK;\n}\n</code></pre> In the same way, during the write phase of the main loop, the <code>write</code> method of all loaded hardware components is called after the controller <code>update</code> in the realtime loop. For this reason, the <code>write</code> method must also obey by realtime constraints. The <code>write</code> method is responsible for updating the data values of the <code>command_interfaces</code>.  In the case of our scara robot, the methods is defined as follows: <pre><code>hardware_interface::return_type write(const rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) {\n    // send command interface values to hardware, e.g joint set joint velocity\n    bool isNan = false;\n    for (auto i = 0ul; i &lt; hw_commands_position_.size(); i++) {\n        if (hw_commands_position_[i] != hw_commands_position_[i]) isNan = true;\n    }\n\n    if (!isNan) {\n        for (uint i = 0; i &lt; info_.joints.size(); i++) {\n            double min_position = std::stod(info_.joints[i].state_interfaces[0].min);\n            double max_position = std::stod(info_.joints[i].state_interfaces[0].max);\n\n            hw_states_position_[i] = hw_commands_position_[i];\n\n            if(hw_states_position_[i] &gt; max_position) hw_states_position_[i] = max_position;\n            if(hw_states_position_[i] &lt; min_position) hw_states_position_[i] = min_position;\n        }\n    }\n\n    return hardware_interface::return_type::OK;\n}\n</code></pre> Notice here that in the first part of the methods we check if the value command is valid (i.e. not NAN), that means that a command was received through the <code>command_interface</code>. Also, notice that we can use some information from the ros2_control description file such as position <code>min</code> and <code>max</code> parameters to prevent the robot to go outside of the its limits.<p></p> <p>Now that we have defined our hardware interface, let's focus on building it in the next section.</p>"},{"location":"tutorials/hardware_tutorial/#building-the-hardware-interface-plugin","title":"Building the Hardware Interface plugin","text":"<p>Building the Hardware Interface plugin is done with the following steps: * Adding C++ export macro  * Creating the plugin description file * Exporting the CMake library</p>"},{"location":"tutorials/hardware_tutorial/#adding-c-export-macro","title":"Adding C++ export macro","text":"<p>In order to reference the previously defined hardware interface as a ros2_control plugin, we need to add the following two lines of code at the end of the scara_robot.cpp file containing our method definitions:</p> <p></p><pre><code>#include \"pluginlib/class_list_macros.hpp\"\n\nPLUGINLIB_EXPORT_CLASS(scara_hardware::ScaraRobot, hardware_interface::SystemInterface)\n</code></pre> The <code>PLUGINLIB_EXPORT_CLASS</code> is a c++ macro that creates a plugin library using <code>pluginlib</code>. More information about it can be found here.<p></p>"},{"location":"tutorials/hardware_tutorial/#creating-the-plugin-description-file","title":"Creating the plugin description file","text":"<p>The plugin description file is a required XML file that describes the plugin's library name, class type, namespace, description, and interface type. This file allows ROS2 to automatically discover and load plugins. It is formatted as follows:</p> <pre><code>&lt;library path=\"{Library_Name}\"&gt;\n  &lt;class\n    name=\"{Namespace}/{Class_Name}\"\n    type=\"{Namespace}::{Class_Name}\"\n    base_class_type=\"hardware_interface::SystemInterface\"&gt;\n  &lt;description&gt;\n    {Human readable description}\n  &lt;/description&gt;\n  &lt;/class&gt;\n&lt;/library&gt;\n</code></pre> <p>The <code>path</code> attribute of the <code>library</code> tags refers to the cmake library name of the user defined hardware plugin. See here for the complete XML file used for this tutorial.</p>"},{"location":"tutorials/hardware_tutorial/#exporting-the-cmake-library","title":"Exporting the CMake library","text":"<p>The general CMake template to make a hardware plugin available in ros2_control is shown below: </p><pre><code>add_library(\n    scara_hardware\n    SHARED\n    src/scara_robot.cpp\n)\n\n# include and link dependencies\n# ...\n\n# Causes the visibility macros to use dllexport rather than dllimport, which is appropriate when building the dll but not consuming it.\ntarget_compile_definitions(scara_hardware PRIVATE \"HARDWARE_PLUGIN_DLL\")\n# export plugin\npluginlib_export_plugin_description_file(scara_hardware scara_hardware_plugin.xml)\n# install libraries\n# ...\n</code></pre> Notice that a library is created using the plugin source code just like any other cmake library. In addition, an extra compile definition and cmake export macro (<code>pluginlib_export_plugin_description_file</code>) need to be added. See here for the complete <code>CMakeLists.txt</code> file used for this tutorial. <p></p> <p>Now that our scara robot's hardware is ready to be loaded as a plugin let's run our scara robot!</p> <p>To do so you just need to specify your hardware plugin in the ros2_control urdf description file as follows: </p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name = \"scara\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n    &lt;ros2_control name=\"scara\" type=\"system\"&gt;\n        &lt;hardware&gt;\n            &lt;plugin&gt;scara_hardware/ScaraRobot&lt;/plugin&gt;\n        &lt;/hardware&gt;\n    &lt;!-- joints, gpios, sensors --&gt;\n    &lt;/ros2_control&gt;\n&lt;/robot&gt;\n</code></pre><p></p> <p>Now you can test your hardware as explained in the previous section on launching and interacting with the hardware, or got further and see the section on how to develop a custom controller.</p>"},{"location":"tutorials/launch_tutorial/","title":"Launch & Interaction","text":""},{"location":"tutorials/launch_tutorial/#launching-and-interacting-with-the-scara-robot","title":"Launching and interacting with the Scara robot","text":"<p>In ros2_control, there is one main node responsible for running the framework, which is the <code>ControllerManager</code>. In this section, we will focus on how to set up and run this node and how to interact with it. </p>"},{"location":"tutorials/launch_tutorial/#configuring-the-controller-manager","title":"Configuring the Controller Manager","text":"<p>The <code>ControllerManager</code> node requires in addition to the robot description a configuration file with additional parameters, such as the control loop update rate, as well as a list of the desired controllers and their parameters. Such a configuration file is usually formatted as follows: </p><pre><code>controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    {controller_name}:\n        type: {namespace}/{class_name}\n\n{controller_name}:\n  ros__parameters:\n    # controller parameters\n</code></pre> In the controller configuration file, the <code>update_rate</code> parameter allows to set the update rate of the <code>ControllerManager</code> node. In addition, the desired controllers that we plan to run need to be referenced and set up. <p></p> <p>In the example of the scara robot, the configuration file is the following: </p><pre><code>controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    scara_position_controller:\n      type: position_controllers/JointGroupPositionController\n\nscara_position_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n</code></pre> In this configuration the <code>update_rate</code> is set at 100Hz and 2 controllers are referenced: * The <code>joint_state_broadcaster</code>, which is of type <code>JointStateBroadcaster</code>, is a general purpose controller available in the <code>ros2_controllers</code> package. This controller is a broadcaster, which means that it does not command the robot but only publishes its state to make it available to other ros2 components. * The <code>scara_position_controller</code>, which is of type <code>JointGroupPositionController</code>, is also a general purpose controller available in the <code>ros2_controllers</code> package. The purpose of this controller is to command the robot joints using the position interface. <p></p> <p>Notice here, that in contrary to the <code>joint_state_broadcaster</code> that streams by default all states of all joints, the <code>scara_position_controller</code> requires additional parameters that specify the targeted joint names. </p> <p>For more information about available controllers and their usage refer to the <code>ros2_controllers</code> package. </p> <p>Now that we have the robot URDF description and the configuration for the Controller Manager node, let's create a launch file to run the scara robot. </p>"},{"location":"tutorials/launch_tutorial/#creating-a-launch-file","title":"Creating a launch file","text":"<p>In the <code>scara.launch.py</code> file, we first need to load the robot description from URDF. As we use XACRO, the global description file <code>scara.config.xacro</code> of the robot needs to be evaluated first, what can be achieved as follows: </p><pre><code>robot_description_content = Command([\n    PathJoinSubstitution([FindExecutable(name='xacro')]),\n    ' ',\n    PathJoinSubstitution(\n        [FindPackageShare('scara_description'), 'config', 'scara.config.xacro']\n    ),\n])\nrobot_description = {'robot_description': robot_description_content}\n</code></pre><p></p> <p>In addition we need to load the previously defined configuration file for the Controller Manager. This can be done as follows: </p> <p></p><pre><code>robot_controllers = PathJoinSubstitution(\n    [\n        FindPackageShare('scara_description'),\n        'config',\n        'scara_controllers.yaml',\n    ]\n)\n</code></pre> With this done, we can now create a node running the ros2_control Controller Manager as follows: <pre><code>control_node = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[robot_description, robot_controllers],\n        output='both',\n    )\n</code></pre> For the purpose of this tutorial you will also need to launch an <code>rviz2</code> node as well as <code>robot_state_publisher</code>, which are required to have a visual of the scara robot. <p></p> <p>See here for the complete launch file used for this tutorial. </p>"},{"location":"tutorials/launch_tutorial/#running-and-interacting-with-the-scara-robot","title":"Running and interacting with the scara robot","text":"<p>After building your workspace, you can run the launch file using: </p><pre><code>$ ros2 launch scara_bringup scara.launch.py \n</code></pre> A RViz2 window should open and display the following: <p></p> <p>This output indicates that the <code>robot_state_publisher</code> node does not have any information about the robot current state. This is not an error in the configuration of your robot and is due to the fact that by default, the <code>controller_manager</code> node does not load any controllers, including the <code>joint_state_broadcaster</code> responsible for sharing the state data with the ROS2 environment. </p> <p>The ros2_control framework comes with some command line functionalities that allow you to interact with Controller Manager. For example, to see what are the hardware interfaces that are currently running, run in a new terminal:  </p><pre><code>$ ros2 control list_hardware_interfaces\n</code></pre> which should produce the following output:  <pre><code>command interfaces\n    joint1/position [available] [unclaimed]\n    joint2/position [available] [unclaimed]\n    joint3/position [available] [unclaimed]\nstate interfaces\n    joint1/position\n    joint1/velocity\n    joint2/position\n    joint2/velocity\n    joint3/position\n    joint3/velocity\n</code></pre> This shows, as expected from the robot description, that a position command interface is available for all joints and that for each joint there is a position and velocity state interface. Notice also the <code>unclaimed</code> flag next to the command interfaces. This flag indicates that no controller was loaded to claim this particular command interface. In fact, if you now run: <pre><code>$ ros2 control list_controllers\n</code></pre> it will give you and empty output. In this case, let's load the <code>joint_state_broadcaster</code>. To do so, run in your terminal: <pre><code>$ ros2 control load_controller joint_state_broadcaster --set-state active\n</code></pre> what should return; <pre><code>Successfully loaded controller joint_state_broadcaster into state active\n</code></pre> Now have a look at your RViz2 window. It should finally display the expected output: <p></p> <p>Also, if you run again: </p><pre><code>$ ros2 control list_controllers\n</code></pre> it will output: <pre><code>joint_state_broadcaster[joint_state_broadcaster/JointStateBroadcaster] active\n</code></pre> This means that only the <code>joint_state_broadcaster</code> is currently running. This particular controller is responsible for reading the states from the hardware and publishing them in the <code>\\joint_states</code> topic, so that it can be interpreted by the robot state publisher node and displayed in RViz2. You can also read the current state of the robot by listening directly to the <code>\\joint_states</code> topic by running: <pre><code>$ ros2 topic echo /joint_states\n</code></pre> Even though the <code>joint_state_broadcaster</code> is a controller, it does not command any interface of the robot. In the next section, let's focus on running another controller that this time will move the robot. <p></p>"},{"location":"tutorials/launch_tutorial/#controlling-joints-with-controllers","title":"Controlling joints with controllers","text":"<p>Let's now focus on another controller that was set up in the <code>scara_controllers.yaml</code> configuration file. In order to give position commands to the scara robot, load the <code>scara_position_controller</code> by running: </p><pre><code>$ ros2 control load_controller scara_position_controller --set-state active\n</code></pre> Now if you run: <pre><code>$ ros2 control list_controllers\n</code></pre> that should give you:  <pre><code>joint_state_broadcaster[joint_state_broadcaster/JointStateBroadcaster] active    \nscara_position_controller[position_controllers/JointGroupPositionController] active \n</code></pre> Your <code>scara_position_controller</code> is now ready to receive position commands. In fact, if you run  <pre><code>$ ros2 topic list\n</code></pre> you will see that a new topic <code>/scara_position_controller/commands</code> appeared. Let's inspect this topic by running : <pre><code>$ ros2 topic info /scara_position_controller/commands \n</code></pre> which will output: <pre><code>Type: std_msgs/msg/Float64MultiArray\nPublisher count: 0\nSubscription count: 1\n</code></pre> This shows you that the expected command message format is of type <code>Float64MultiArray</code>. Let's check how this message type is defined by running : <pre><code>$ ros2 interface show std_msgs/msg/Float64MultiArray\n</code></pre> which will return : <pre><code># Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nfloat64[]         data          # array of data\n</code></pre> The expected message is an array of <code>float64</code>. Let's now publish a set of position commands on that topic:  <pre><code>ros2 topic pub --once /scara_position_controller/commands std_msgs/msg/Float64MultiArray \"{data: [0.5,-1.5,0.3]}\"\n</code></pre> Your robot moved to the desired position!  Notice here that the motion to the desired position was done in one shot, what on a real robot would require excessive torques. In the case of a real robot, it would be more suited to use another controller that is able of interpolating the robot motion such as the <code>joint_trajectory_controller</code>. After adding the new controller to the configuration file as the <code>scara_trajectory_controller</code>, let's see how to switch from one controller to the other. We consider that the application was not stopped and that the <code>scara_position_controller</code> is still running.<p></p> <p>At first, the new controller needs to be loaded. If we run the previous command: </p><pre><code>$ ros2 control load_controller scara_trajectory_controller --set-state active\n</code></pre> it will return: <pre><code>[ERROR] [1663347965.049772820] [controller_manager]: Resource conflict for controller 'scara_trajectory_controller'. Command interface 'joint1/position' is already claimed.\n</code></pre> As explained in the overview section, the command interfaces are exclusively accessed to avoid this particular case where two controllers claim the same interface. To deal with it, the <code>scara_position_controller</code> needs to release the interface before the <code>scara_trajectory_controller</code> can claim it. One way of doing it is to first deactivate the <code>scara_position_controller</code> by running: <pre><code>$ ros2 control set_controller_state scara_position_controller inactive \n</code></pre> and then activate the other controller by running: <pre><code>$ ros2 control set_controller_state scara_trajectory_controller active \n</code></pre> As a result, the controllers are switched what can be checked running once again: <pre><code>$ ros2 control list_controllers\n</code></pre> that should give you:  <pre><code>joint_state_broadcaster[joint_state_broadcaster/JointStateBroadcaster] active    \nscara_position_controller[position_controllers/JointGroupPositionController] inactive \nscara_trajectory_controller[joint_trajectory_controller/JointTrajectoryController] active\n</code></pre><p></p> <p>Alternatively, in order to avoid the period where teh hardware is not controlled, both actions can be done simultaneously by running:  </p><pre><code>$ ros2 control switch_controllers --deactivate scara_position_controller --activate scara_trajectory_controller\n</code></pre><p></p> <p>Notice that in order to be able to activate the <code>scara_trajectory_controller</code>, its state needs to be <code>inactive</code> meaning that is was already configured. In order to configure the controller without activating it, you can run:  </p><pre><code>ros2 control load_controller scara_trajectory_controller --set-state configured\n</code></pre><p></p>"},{"location":"tutorials/launch_tutorial/#additional-comments-on-controllers","title":"Additional comments on controllers","text":"<p>In ros2_control, controllers can be loaded, unloaded and switched on runtime without stopping the hardware. This allows to address the need of applications that have multiple different operating phases. More information can be found here.</p> <p>Also, in most applications the controller to be loaded is known from start and therefore it can be loaded directly at startup in the launch file by calling the <code>spawner</code> node: </p><pre><code>controller_spawner = Node(\n        package='controller_manager',\n        executable='spawner',\n        arguments=['&lt;controller_name&gt;'],\n    )\n</code></pre><p></p> <p>Some additional information about available controllers can be found here. If, however, for the purpose of your applications you need a custom controller, you can go to the section on how to develop one.</p>"},{"location":"tutorials/r2c_overview/","title":"ros2_control Overview","text":""},{"location":"tutorials/r2c_overview/#overview-of-the-ros2_control-framework","title":"Overview of the ros2_control framework","text":"<p>The ros2_control framework is a realtime control framework designed for general robotics applications. It is an abstraction layer for simple integration of hardware and controllers. The ros2_control framework comes with standard interfaces to enhance code modularity and robot agnostic design. Application specific details, such as the controller to be used or the robot description, are easily specified via configuration files. Finally, the ros2_control framework can easily be deployed via ROS2 launch a file.</p> <p>All these features of ros2_control allow to focus on the design of complex application by taking advantage of the possibility to use and reuse as often as possible existing controllers, hardware drivers and freely switch between simulation and execution on a real robotic system. Also, the effort spent on the development of custom controllers or hardware interfaces can easily be reused in many other projects. Finally, using standard components allows to easily integrate 3rd party ROS2 packages into the developed applications.</p> <p></p> <p>In order to better understand how the framework works, let's focus at the components it consists of. </p>"},{"location":"tutorials/r2c_overview/#controller-manager","title":"Controller Manager","text":"<p>The Controller Manager is the main component in the ros2_control framework, which connects the controllers and hardware-abstraction sides of the framework. It also serves as the entry-point for users through ROS services. The Controller Manager implements a node without an executor so it can be integrated into a custom setup. Still, for a standard user, it is recommended to use the default node-setup implemented in <code>ros2_control_node</code> file from the <code>controller_manager</code> package.</p> <p>On the one side, Controller Manager manages (e.g., loading, activating, deactivating, unloading) controllers and the interfaces they require. On the other side, it has access to the hardware components through the Resource Manager. The Controller Manager matches required and provided interfaces, gives controllers access to hardware when activated, or reports an error if there is an access conflict.</p> <p>The execution of the different components of the ros2_control framework in the control-loop is managed by the Controller Manager. At each loop iteration, it reads data from the hardware components, updates outputs of all active controllers, and writes the result to the components.</p> <p>The Controller Manager's control loop update can be summarized as follows: </p>"},{"location":"tutorials/r2c_overview/#resource-manager","title":"Resource Manager","text":"<p>The Resource Manager abstracts physical hardware and its drivers (called hardware components) for the ros2_control framework. The Resource Manager loads the components as plugins. It also manages the components' lifecycle and as well as state and command interfaces. This abstraction provided by the Resource Manager enables re-usability of implemented hardware components, e.g., robot and gripper, without any implementation and flexible hardware application for state and command interfaces, e.g., separate hardware/communication libraries for motor control and encoder reading.</p> <p>In the control loop execution managed by the Controller Manager, the Resource Manager\u2019s <code>read()</code> and <code>write()</code> methods are called and deal with communication to the hardware components.</p>"},{"location":"tutorials/r2c_overview/#controllers","title":"Controllers","text":"<p>The controllers in the ros2_control framework have the same functionality as defined in the control theory. They compare the reference value with the measured output and, based on this error, calculate a system\u2019s input. The controllers are loaded as plugins making their development independent of the framework. In ros2_control, controllers are managed node, which means that they work as state-machines and thus have a finite set of states, which are:</p> <ol> <li>Unconfigured</li> <li>Inactive</li> <li>Active</li> <li>Finalized</li> </ol> <p>This configuration has several advantages: - It allows to have greater control over the current state of the controller and ensure that it has been correctly instantiated before being executed.  - It allows to load, restart and replace controllers on-line. </p> <p>Notice here also, that in order to be executed by the Controller Manager and command the hardware, the controller needs to be in <code>active</code> state. </p> <p>When executing the control-loop, the Controller Manager calls the <code>update()</code> method of all controllers. This method can access the latest hardware states and enable the controller to send commands to the hardware interfaces.</p>"},{"location":"tutorials/r2c_overview/#hardware-abstraction","title":"Hardware Abstraction","text":"<p>The hardware abstraction layer is done using ros2_control hardware components that realize the communication to physical hardware and represent its abstraction in the ros2_control framework. The components have to be exported as plugins. The Resource Manager dynamically loads those plugins and manages their lifecycle.</p> <p>There are three basic types of components:</p> <ol> <li> <p>System: Complex (multi-DOF) robotic hardware like industrial robots. The main difference between the Actuator component is the possibility to use complex transmissions like needed for humanoid robot\u2019s hands. This component has reading and writing capabilities. It is used when the is only one logical communication channel to the hardware, such as when using a robot driver and SDK.</p> </li> <li> <p>Sensor: Hardware used for sensing some environment parameters. This component type has only reading capabilities.</p> </li> <li> <p>Actuator: Simple (1 DOF) robotic hardware like motors, valves, and similar. An actuator implementation is related to only one joint. This component type has reading and writing capabilities. Reading is not mandatory if not possible (e.g., DC motor control with Arduino board). The actuator type can also be used with a multi-DOF robot if its hardware enables modular design, e.g., CAN-communication with each motor independently.</p> </li> </ol>"},{"location":"tutorials/r2c_overview/#state-and-command-interfaces","title":"State and Command Interfaces","text":"<p>Finally, the ros2_control framework introduces <code>state_interfaces</code> and <code>command_interfaces</code> to abstract hardware interfacing. The <code>state_interfaces</code> are read only data handles that generally represent sensors readings, e.g. joint encoder. The <code>command_interfaces</code> are read and write data handles that are used to pass commands to the hardware. The <code>command_interfaces</code> are exclusively accessed, meaning if a controller has \"claimed\" an interface, it cannot be used by any other controller until it is released. This guarantees that two controllers will never be able to send commands to the same hardware in the same time, what could have a dangerous outcome. Both <code>state_interfaces</code> and <code>command_interfaces</code> are set up together with the hardware using configuration files.</p> <p>The overall architecture of the ros2_control framework can be summarized as follows: </p>"},{"location":"tutorials/urdf_tutorial/","title":"URDF Description","text":""},{"location":"tutorials/urdf_tutorial/#writing-the-urdf-description-of-the-scara-robot","title":"Writing the URDF description of the SCARA robot","text":"<p>The URDF file is a standard XML based file used to describe characteristic of a robot. It can represent any robot with a tree structure, except those with cycles. Each link must have only one parent. For ros2_control, there are three primary tags: <code>link</code>, <code>joint</code>, and <code>ros2_control</code>. The <code>joint</code> tag define the robot's kinematic structure, while the <code>link</code> tag defines the dynamic properties and 3D geometry. The <code>ros2_control</code> defines the hardware and controller configuration.</p> <p>A good practice in ROS2 is to specify the description of the used robot in a dedicated package. In this tutorial, the package is named in a standard way <code>scara_description</code>. In this package you can find different folders containing the configuration of the used system for different ROS2 components. </p>"},{"location":"tutorials/urdf_tutorial/#global-urdf-description-using-xacro","title":"Global URDF description using Xacro","text":"<p>In order to simplify the setup of the robot we often build the robot URDF description using <code>xacro</code>. Xacro (XML Macros) is an XML macro language. With xacro, you can construct shorter and more readable XML files by using macros that expand to larger XML expressions. Using xacro allows to include smaller segments of the system description for better readability. For example, in the case of the scara robot, the global URDF is defined using the scara.config.xacro file, formatted as follows:  </p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!-- Scara manipulator --&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"scara\"&gt;\n\n    &lt;!-- Import scara urdf file --&gt;\n    &lt;xacro:include filename=\"$(find scara_description)/urdf/scara.urdf\" /&gt;\n\n    &lt;!-- Import scara materials file --&gt;\n    &lt;xacro:include filename=\"$(find scara_description)/config/materials.urdf\" /&gt;\n\n    &lt;!-- Import scara ros2_control description --&gt;\n    &lt;xacro:include filename=\"$(find scara_description)/ros2_control/scara.ros2_control.urdf\" /&gt;\n\n&lt;/robot&gt;\n</code></pre> In this xml description: * The <code>robot</code> tag encloses all contents of the URDF file. It has a name attribute which must be specified. * The <code>xacro:include</code> tag is used to import the geometric description, the materials file and the ros2_control description.<p></p> <p>In the next sections, let's focus more in details on the included description files. </p>"},{"location":"tutorials/urdf_tutorial/#geometry-and-dynamics","title":"Geometry and Dynamics","text":"<p>In this section, let's focus on the <code>scara.urdf</code> description file. The URDF file describes in details the geometry of the robot as well as some additional parameters such as its visual and collision meshes, dynamics and others. </p> <p>Let's create a robot description for a scara robot with the following structure:</p> <p></p> <p>The resulting URDF description file is generally formatted as follows: </p> <p></p><pre><code>&lt;?xml version = \"1.0\"?&gt;\n&lt;robot name = \"scara\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n\n  &lt;!-- Used for fixing robot to 'base_link' --&gt;\n  &lt;link name=\"world\"/&gt;\n\n  &lt;!-- Base Link --&gt;\n  &lt;link name = \"base_link\"&gt;\n    &lt;visual&gt;\n      &lt;geometry&gt;\n        &lt;box size = \"0.12 0.12 0.05\"/&gt;\n      &lt;/geometry&gt;\n      &lt;material name = \"blue\"/&gt;\n      &lt;origin xyz = \"0 0 0.025\"/&gt;\n    &lt;/visual&gt;\n    &lt;inertial&gt;\n      &lt;mass value=\"1\" /&gt;\n      &lt;origin xyz=\"0 0 0.025\" rpy=\"0 0 0\" /&gt;\n      &lt;inertia ixx=\"1\" ixy=\"0\" ixz=\"0\" iyy=\"1\" iyz=\"0\" izz=\"1\" /&gt;\n    &lt;/inertial&gt;\n    &lt;collision&gt;\n      &lt;geometry&gt;\n        &lt;box size = \"0.12 0.12 0.05\"/&gt;\n      &lt;/geometry&gt;\n      &lt;material name = \"blue\"/&gt;\n      &lt;origin xyz = \"0 0 0.025\"/&gt;\n    &lt;/collision&gt;\n  &lt;/link&gt;\n\n  &lt;joint name=\"base2world\" type=\"fixed\"&gt;\n    &lt;parent link=\"world\"/&gt;\n    &lt;child link=\"base_link\"/&gt;\n  &lt;/joint&gt;\n\n  &lt;!-- revolute1 1 --&gt;\n  &lt;link name = \"revolute1\"&gt;\n    &lt;visual&gt;\n      &lt;geometry&gt;\n        &lt;cylinder length = \"0.45\" radius = \"0.05\"/&gt;\n      &lt;/geometry&gt;\n      &lt;material name = \"green\"/&gt;\n      &lt;origin xyz = \"0 0 0.225\"/&gt;\n    &lt;/visual&gt;\n    &lt;inertial&gt;\n      &lt;mass value=\"0.5\" /&gt;\n      &lt;origin xyz=\"0 0 0.05\" rpy=\"0 0 0\" /&gt;\n      &lt;inertia ixx=\"0.5\" ixy=\"0\" ixz=\"0\" iyy=\"0.5\" iyz=\"0\" izz=\"0.5\" /&gt;\n    &lt;/inertial&gt;\n    &lt;collision&gt;\n      &lt;geometry&gt;\n        &lt;cylinder length = \"0.45\" radius = \"0.05\"/&gt;\n      &lt;/geometry&gt;\n      &lt;material name = \"green\"/&gt;\n      &lt;origin xyz = \"0 0 0.225\"/&gt;\n    &lt;/collision&gt;\n  &lt;/link&gt;\n\n  &lt;joint name = \"joint1\" type=\"revolute\"&gt;\n    &lt;parent link = \"base_link\"/&gt;\n    &lt;child link = \"revolute1\"/&gt;\n    &lt;origin xyz = \"0 0 0.05\"/&gt;\n    &lt;limit effort=\"1000.0\" lower=\"-1.57\" upper=\"1.57\" velocity=\"0.5\"/&gt;\n    &lt;axis xyz = \"0 0 1\"/&gt;\n    &lt;dynamics damping=\"0.2\" friction=\"0.1\" /&gt;\n  &lt;/joint&gt;\n\n  &lt;!-- additional links and joints --&gt;\n\n&lt;/robot&gt;\n</code></pre> In this xml description: * The <code>robot</code> tag encloses all contents of the URDF file. It has a name attribute which must be specified. * The <code>link</code> tag defines the robot's geometry and inertia properties. It has a name attribute which will be referred to by the <code>joint</code> tags. * The <code>visual</code> tag specifies the rotation and translation of the visual shapes. The shapes require to set the <code>origin</code> tag to fit the desired link shape. * The <code>geometry</code>, <code>box</code> and <code>cylinder</code> tags specify the geometry of the robot link. Alternatively, you can also use the <code>mesh</code> tag to specify the location of the 3D mesh file relative to a specified ROS 2 package. * The <code>collision</code> tag is equivalent to the <code>visual</code> tag, except the specified mesh is used for collision checking in some applications. * The <code>inertial</code> tag specifies mass and inertia for the link. The origin tag specifies the link's center of mass. These values are used to calculate forward and inverse dynamics. Since our application does not use dynamics, uniform arbitrary values are used. * The <code>&lt;!-- additional links ... --&gt;</code> comments indicates that many consecutive <code>link</code> tags will be defined, one for each link. * The <code>&lt;link name=\"world\"/&gt;</code> and <code>&lt;link name=\"tool0\"/&gt;</code> elements are not required. However, it is convention to set the link at the tip of the robot to  tool0 and to define the robot's base link relative to a world frame. * The <code>joint</code> tag specifies the kinematic structure of the robot. It two required attributes: name and type. The type specifies the viable motion between the two connected links. The subsequent <code>parent</code> and <code>child</code> links specify which two links are joined by the joint. * The <code>axis</code> tag species the joint's axis of rotation. If the meshes were process as described previously, then the axis value is always <code>\"0 0 1\"</code>. * The <code>limits</code> tag specifies kinematic and dynamic limits for the joint. * The <code>dynamics</code> tag specifies some dynamics properties of the joint such as its damping or friction coefficients.<p></p>"},{"location":"tutorials/urdf_tutorial/#hardware-interface-setup-for-ros2_control","title":"Hardware Interface setup for ros2_control","text":"<p>In this section, let's focus on the <code>scara.ros2_control.urdf</code> description file. This description file is used to set up the ros2_control hardware that will be used to specify the <code>command_interface</code> and <code>state_interface</code> for each <code>joint</code>, <code>sensor</code> and/or <code>gpio</code>. </p> <p>The ros2_control description is generally formatted as follows:  </p> <p></p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name = \"scara\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n\n    &lt;ros2_control name=\"scara\" type=\"system\"&gt;\n\n        &lt;hardware&gt;\n            &lt;plugin&gt;mock_components/GenericSystem&lt;/plugin&gt;\n        &lt;/hardware&gt;\n\n        &lt;joint name=\"joint1\"&gt;\n            &lt;command_interface name=\"position\" /&gt;\n            &lt;state_interface name=\"position\"&gt;\n                &lt;param name=\"initial_value\"&gt;0.0&lt;/param&gt;\n                &lt;param name=\"min\"&gt;-1.57&lt;/param&gt;\n                &lt;param name=\"max\"&gt;1.57&lt;/param&gt;\n            &lt;/state_interface&gt;\n            &lt;state_interface name=\"velocity\"&gt; \n                &lt;param name=\"initial_value\"&gt;0.0&lt;/param&gt; \n            &lt;/state_interface&gt;\n        &lt;/joint&gt;\n\n        &lt;!-- additional joints --&gt;\n\n    &lt;/ros2_control&gt;\n\n&lt;/robot&gt;\n</code></pre> In this xml description: * The <code>robot</code> tag encloses all contents of the URDF file. It has a name attribute which must be specified. * The <code>hardware</code> and <code>plugin</code> tags instruct the ros2_control framework to dynamically load a hardware driver conforming to <code>HardwareInterface</code> as a plugin. The plugin is specified as <code>{Name_Space}/{Class_Name}</code>. In this case we use the <code>GenericSystem</code> hardware which is a general purpose simulation hardware available in the <code>ros2_control</code> package.  * The<code>joint</code> tag specifies the state and command interfaces that the loaded plugin will offer. The joint is specified with the name attribute. The <code>command_interface</code> and <code>state_interface</code> tags specify the interface type, usually position, velocity, acceleration, or effort. Additionally, for each interface additional parameters such as <code>min</code>, <code>max</code> and <code>initial_value</code> can be set.  <p></p> <p>The hardware interface that can be loaded here as a plugin is dependant of the type of robot that is controlled and its control mode. It is an interface between ros2_control and the robot driver. For robots that support ros2_control, the interface is often given either by the manufacturer or the community. A non exhaustive list of available hardware interfaces can be found here. </p> <p>At this point you can either go further to the next section on how to launch and interact with the current system. In the case where the hardware interface that you want to use is not already available, you can go to the section on how to develop a custom one.</p>"}]}